// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'failures.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

/// @nodoc
mixin _$Failure {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() loggedOut,
    required TResult Function() network,
    required TResult Function(DateTime? cooldownEndDate) quotaExceeded,
    required TResult Function() serviceNotFound,
    required TResult Function() serviceAlreadyExists,
    required TResult Function() insufficientFunds,
    required TResult Function() unauthorized,
    required TResult Function() invalidValue,
    required TResult Function(Object? cause, StackTrace? stack) other,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? loggedOut,
    TResult? Function()? network,
    TResult? Function(DateTime? cooldownEndDate)? quotaExceeded,
    TResult? Function()? serviceNotFound,
    TResult? Function()? serviceAlreadyExists,
    TResult? Function()? insufficientFunds,
    TResult? Function()? unauthorized,
    TResult? Function()? invalidValue,
    TResult? Function(Object? cause, StackTrace? stack)? other,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? loggedOut,
    TResult Function()? network,
    TResult Function(DateTime? cooldownEndDate)? quotaExceeded,
    TResult Function()? serviceNotFound,
    TResult Function()? serviceAlreadyExists,
    TResult Function()? insufficientFunds,
    TResult Function()? unauthorized,
    TResult Function()? invalidValue,
    TResult Function(Object? cause, StackTrace? stack)? other,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_LoggedOut value) loggedOut,
    required TResult Function(_NetworkFailure value) network,
    required TResult Function(_QuotaExceededFailure value) quotaExceeded,
    required TResult Function(_ServiceNotFound value) serviceNotFound,
    required TResult Function(_ServiceAlreadyExists value) serviceAlreadyExists,
    required TResult Function(_InsuffientFunds value) insufficientFunds,
    required TResult Function(_Inauthorized value) unauthorized,
    required TResult Function(_InvalidValue value) invalidValue,
    required TResult Function(_OtherFailure value) other,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_LoggedOut value)? loggedOut,
    TResult? Function(_NetworkFailure value)? network,
    TResult? Function(_QuotaExceededFailure value)? quotaExceeded,
    TResult? Function(_ServiceNotFound value)? serviceNotFound,
    TResult? Function(_ServiceAlreadyExists value)? serviceAlreadyExists,
    TResult? Function(_InsuffientFunds value)? insufficientFunds,
    TResult? Function(_Inauthorized value)? unauthorized,
    TResult? Function(_InvalidValue value)? invalidValue,
    TResult? Function(_OtherFailure value)? other,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_LoggedOut value)? loggedOut,
    TResult Function(_NetworkFailure value)? network,
    TResult Function(_QuotaExceededFailure value)? quotaExceeded,
    TResult Function(_ServiceNotFound value)? serviceNotFound,
    TResult Function(_ServiceAlreadyExists value)? serviceAlreadyExists,
    TResult Function(_InsuffientFunds value)? insufficientFunds,
    TResult Function(_Inauthorized value)? unauthorized,
    TResult Function(_InvalidValue value)? invalidValue,
    TResult Function(_OtherFailure value)? other,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $FailureCopyWith<$Res> {
  factory $FailureCopyWith(Failure value, $Res Function(Failure) then) =
      _$FailureCopyWithImpl<$Res, Failure>;
}

/// @nodoc
class _$FailureCopyWithImpl<$Res, $Val extends Failure>
    implements $FailureCopyWith<$Res> {
  _$FailureCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$LoggedOutImplCopyWith<$Res> {
  factory _$$LoggedOutImplCopyWith(
          _$LoggedOutImpl value, $Res Function(_$LoggedOutImpl) then) =
      __$$LoggedOutImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$LoggedOutImplCopyWithImpl<$Res>
    extends _$FailureCopyWithImpl<$Res, _$LoggedOutImpl>
    implements _$$LoggedOutImplCopyWith<$Res> {
  __$$LoggedOutImplCopyWithImpl(
      _$LoggedOutImpl _value, $Res Function(_$LoggedOutImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$LoggedOutImpl extends _LoggedOut {
  const _$LoggedOutImpl() : super._();

  @override
  String toString() {
    return 'Failure.loggedOut()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$LoggedOutImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() loggedOut,
    required TResult Function() network,
    required TResult Function(DateTime? cooldownEndDate) quotaExceeded,
    required TResult Function() serviceNotFound,
    required TResult Function() serviceAlreadyExists,
    required TResult Function() insufficientFunds,
    required TResult Function() unauthorized,
    required TResult Function() invalidValue,
    required TResult Function(Object? cause, StackTrace? stack) other,
  }) {
    return loggedOut();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? loggedOut,
    TResult? Function()? network,
    TResult? Function(DateTime? cooldownEndDate)? quotaExceeded,
    TResult? Function()? serviceNotFound,
    TResult? Function()? serviceAlreadyExists,
    TResult? Function()? insufficientFunds,
    TResult? Function()? unauthorized,
    TResult? Function()? invalidValue,
    TResult? Function(Object? cause, StackTrace? stack)? other,
  }) {
    return loggedOut?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? loggedOut,
    TResult Function()? network,
    TResult Function(DateTime? cooldownEndDate)? quotaExceeded,
    TResult Function()? serviceNotFound,
    TResult Function()? serviceAlreadyExists,
    TResult Function()? insufficientFunds,
    TResult Function()? unauthorized,
    TResult Function()? invalidValue,
    TResult Function(Object? cause, StackTrace? stack)? other,
    required TResult orElse(),
  }) {
    if (loggedOut != null) {
      return loggedOut();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_LoggedOut value) loggedOut,
    required TResult Function(_NetworkFailure value) network,
    required TResult Function(_QuotaExceededFailure value) quotaExceeded,
    required TResult Function(_ServiceNotFound value) serviceNotFound,
    required TResult Function(_ServiceAlreadyExists value) serviceAlreadyExists,
    required TResult Function(_InsuffientFunds value) insufficientFunds,
    required TResult Function(_Inauthorized value) unauthorized,
    required TResult Function(_InvalidValue value) invalidValue,
    required TResult Function(_OtherFailure value) other,
  }) {
    return loggedOut(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_LoggedOut value)? loggedOut,
    TResult? Function(_NetworkFailure value)? network,
    TResult? Function(_QuotaExceededFailure value)? quotaExceeded,
    TResult? Function(_ServiceNotFound value)? serviceNotFound,
    TResult? Function(_ServiceAlreadyExists value)? serviceAlreadyExists,
    TResult? Function(_InsuffientFunds value)? insufficientFunds,
    TResult? Function(_Inauthorized value)? unauthorized,
    TResult? Function(_InvalidValue value)? invalidValue,
    TResult? Function(_OtherFailure value)? other,
  }) {
    return loggedOut?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_LoggedOut value)? loggedOut,
    TResult Function(_NetworkFailure value)? network,
    TResult Function(_QuotaExceededFailure value)? quotaExceeded,
    TResult Function(_ServiceNotFound value)? serviceNotFound,
    TResult Function(_ServiceAlreadyExists value)? serviceAlreadyExists,
    TResult Function(_InsuffientFunds value)? insufficientFunds,
    TResult Function(_Inauthorized value)? unauthorized,
    TResult Function(_InvalidValue value)? invalidValue,
    TResult Function(_OtherFailure value)? other,
    required TResult orElse(),
  }) {
    if (loggedOut != null) {
      return loggedOut(this);
    }
    return orElse();
  }
}

abstract class _LoggedOut extends Failure {
  const factory _LoggedOut() = _$LoggedOutImpl;
  const _LoggedOut._() : super._();
}

/// @nodoc
abstract class _$$NetworkFailureImplCopyWith<$Res> {
  factory _$$NetworkFailureImplCopyWith(_$NetworkFailureImpl value,
          $Res Function(_$NetworkFailureImpl) then) =
      __$$NetworkFailureImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$NetworkFailureImplCopyWithImpl<$Res>
    extends _$FailureCopyWithImpl<$Res, _$NetworkFailureImpl>
    implements _$$NetworkFailureImplCopyWith<$Res> {
  __$$NetworkFailureImplCopyWithImpl(
      _$NetworkFailureImpl _value, $Res Function(_$NetworkFailureImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$NetworkFailureImpl extends _NetworkFailure {
  const _$NetworkFailureImpl() : super._();

  @override
  String toString() {
    return 'Failure.network()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$NetworkFailureImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() loggedOut,
    required TResult Function() network,
    required TResult Function(DateTime? cooldownEndDate) quotaExceeded,
    required TResult Function() serviceNotFound,
    required TResult Function() serviceAlreadyExists,
    required TResult Function() insufficientFunds,
    required TResult Function() unauthorized,
    required TResult Function() invalidValue,
    required TResult Function(Object? cause, StackTrace? stack) other,
  }) {
    return network();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? loggedOut,
    TResult? Function()? network,
    TResult? Function(DateTime? cooldownEndDate)? quotaExceeded,
    TResult? Function()? serviceNotFound,
    TResult? Function()? serviceAlreadyExists,
    TResult? Function()? insufficientFunds,
    TResult? Function()? unauthorized,
    TResult? Function()? invalidValue,
    TResult? Function(Object? cause, StackTrace? stack)? other,
  }) {
    return network?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? loggedOut,
    TResult Function()? network,
    TResult Function(DateTime? cooldownEndDate)? quotaExceeded,
    TResult Function()? serviceNotFound,
    TResult Function()? serviceAlreadyExists,
    TResult Function()? insufficientFunds,
    TResult Function()? unauthorized,
    TResult Function()? invalidValue,
    TResult Function(Object? cause, StackTrace? stack)? other,
    required TResult orElse(),
  }) {
    if (network != null) {
      return network();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_LoggedOut value) loggedOut,
    required TResult Function(_NetworkFailure value) network,
    required TResult Function(_QuotaExceededFailure value) quotaExceeded,
    required TResult Function(_ServiceNotFound value) serviceNotFound,
    required TResult Function(_ServiceAlreadyExists value) serviceAlreadyExists,
    required TResult Function(_InsuffientFunds value) insufficientFunds,
    required TResult Function(_Inauthorized value) unauthorized,
    required TResult Function(_InvalidValue value) invalidValue,
    required TResult Function(_OtherFailure value) other,
  }) {
    return network(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_LoggedOut value)? loggedOut,
    TResult? Function(_NetworkFailure value)? network,
    TResult? Function(_QuotaExceededFailure value)? quotaExceeded,
    TResult? Function(_ServiceNotFound value)? serviceNotFound,
    TResult? Function(_ServiceAlreadyExists value)? serviceAlreadyExists,
    TResult? Function(_InsuffientFunds value)? insufficientFunds,
    TResult? Function(_Inauthorized value)? unauthorized,
    TResult? Function(_InvalidValue value)? invalidValue,
    TResult? Function(_OtherFailure value)? other,
  }) {
    return network?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_LoggedOut value)? loggedOut,
    TResult Function(_NetworkFailure value)? network,
    TResult Function(_QuotaExceededFailure value)? quotaExceeded,
    TResult Function(_ServiceNotFound value)? serviceNotFound,
    TResult Function(_ServiceAlreadyExists value)? serviceAlreadyExists,
    TResult Function(_InsuffientFunds value)? insufficientFunds,
    TResult Function(_Inauthorized value)? unauthorized,
    TResult Function(_InvalidValue value)? invalidValue,
    TResult Function(_OtherFailure value)? other,
    required TResult orElse(),
  }) {
    if (network != null) {
      return network(this);
    }
    return orElse();
  }
}

abstract class _NetworkFailure extends Failure {
  const factory _NetworkFailure() = _$NetworkFailureImpl;
  const _NetworkFailure._() : super._();
}

/// @nodoc
abstract class _$$QuotaExceededFailureImplCopyWith<$Res> {
  factory _$$QuotaExceededFailureImplCopyWith(_$QuotaExceededFailureImpl value,
          $Res Function(_$QuotaExceededFailureImpl) then) =
      __$$QuotaExceededFailureImplCopyWithImpl<$Res>;
  @useResult
  $Res call({DateTime? cooldownEndDate});
}

/// @nodoc
class __$$QuotaExceededFailureImplCopyWithImpl<$Res>
    extends _$FailureCopyWithImpl<$Res, _$QuotaExceededFailureImpl>
    implements _$$QuotaExceededFailureImplCopyWith<$Res> {
  __$$QuotaExceededFailureImplCopyWithImpl(_$QuotaExceededFailureImpl _value,
      $Res Function(_$QuotaExceededFailureImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? cooldownEndDate = freezed,
  }) {
    return _then(_$QuotaExceededFailureImpl(
      cooldownEndDate: freezed == cooldownEndDate
          ? _value.cooldownEndDate
          : cooldownEndDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
    ));
  }
}

/// @nodoc

class _$QuotaExceededFailureImpl extends _QuotaExceededFailure {
  const _$QuotaExceededFailureImpl({this.cooldownEndDate}) : super._();

  @override
  final DateTime? cooldownEndDate;

  @override
  String toString() {
    return 'Failure.quotaExceeded(cooldownEndDate: $cooldownEndDate)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$QuotaExceededFailureImpl &&
            (identical(other.cooldownEndDate, cooldownEndDate) ||
                other.cooldownEndDate == cooldownEndDate));
  }

  @override
  int get hashCode => Object.hash(runtimeType, cooldownEndDate);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$QuotaExceededFailureImplCopyWith<_$QuotaExceededFailureImpl>
      get copyWith =>
          __$$QuotaExceededFailureImplCopyWithImpl<_$QuotaExceededFailureImpl>(
              this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() loggedOut,
    required TResult Function() network,
    required TResult Function(DateTime? cooldownEndDate) quotaExceeded,
    required TResult Function() serviceNotFound,
    required TResult Function() serviceAlreadyExists,
    required TResult Function() insufficientFunds,
    required TResult Function() unauthorized,
    required TResult Function() invalidValue,
    required TResult Function(Object? cause, StackTrace? stack) other,
  }) {
    return quotaExceeded(cooldownEndDate);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? loggedOut,
    TResult? Function()? network,
    TResult? Function(DateTime? cooldownEndDate)? quotaExceeded,
    TResult? Function()? serviceNotFound,
    TResult? Function()? serviceAlreadyExists,
    TResult? Function()? insufficientFunds,
    TResult? Function()? unauthorized,
    TResult? Function()? invalidValue,
    TResult? Function(Object? cause, StackTrace? stack)? other,
  }) {
    return quotaExceeded?.call(cooldownEndDate);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? loggedOut,
    TResult Function()? network,
    TResult Function(DateTime? cooldownEndDate)? quotaExceeded,
    TResult Function()? serviceNotFound,
    TResult Function()? serviceAlreadyExists,
    TResult Function()? insufficientFunds,
    TResult Function()? unauthorized,
    TResult Function()? invalidValue,
    TResult Function(Object? cause, StackTrace? stack)? other,
    required TResult orElse(),
  }) {
    if (quotaExceeded != null) {
      return quotaExceeded(cooldownEndDate);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_LoggedOut value) loggedOut,
    required TResult Function(_NetworkFailure value) network,
    required TResult Function(_QuotaExceededFailure value) quotaExceeded,
    required TResult Function(_ServiceNotFound value) serviceNotFound,
    required TResult Function(_ServiceAlreadyExists value) serviceAlreadyExists,
    required TResult Function(_InsuffientFunds value) insufficientFunds,
    required TResult Function(_Inauthorized value) unauthorized,
    required TResult Function(_InvalidValue value) invalidValue,
    required TResult Function(_OtherFailure value) other,
  }) {
    return quotaExceeded(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_LoggedOut value)? loggedOut,
    TResult? Function(_NetworkFailure value)? network,
    TResult? Function(_QuotaExceededFailure value)? quotaExceeded,
    TResult? Function(_ServiceNotFound value)? serviceNotFound,
    TResult? Function(_ServiceAlreadyExists value)? serviceAlreadyExists,
    TResult? Function(_InsuffientFunds value)? insufficientFunds,
    TResult? Function(_Inauthorized value)? unauthorized,
    TResult? Function(_InvalidValue value)? invalidValue,
    TResult? Function(_OtherFailure value)? other,
  }) {
    return quotaExceeded?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_LoggedOut value)? loggedOut,
    TResult Function(_NetworkFailure value)? network,
    TResult Function(_QuotaExceededFailure value)? quotaExceeded,
    TResult Function(_ServiceNotFound value)? serviceNotFound,
    TResult Function(_ServiceAlreadyExists value)? serviceAlreadyExists,
    TResult Function(_InsuffientFunds value)? insufficientFunds,
    TResult Function(_Inauthorized value)? unauthorized,
    TResult Function(_InvalidValue value)? invalidValue,
    TResult Function(_OtherFailure value)? other,
    required TResult orElse(),
  }) {
    if (quotaExceeded != null) {
      return quotaExceeded(this);
    }
    return orElse();
  }
}

abstract class _QuotaExceededFailure extends Failure {
  const factory _QuotaExceededFailure({final DateTime? cooldownEndDate}) =
      _$QuotaExceededFailureImpl;
  const _QuotaExceededFailure._() : super._();

  DateTime? get cooldownEndDate;
  @JsonKey(ignore: true)
  _$$QuotaExceededFailureImplCopyWith<_$QuotaExceededFailureImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$ServiceNotFoundImplCopyWith<$Res> {
  factory _$$ServiceNotFoundImplCopyWith(_$ServiceNotFoundImpl value,
          $Res Function(_$ServiceNotFoundImpl) then) =
      __$$ServiceNotFoundImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$ServiceNotFoundImplCopyWithImpl<$Res>
    extends _$FailureCopyWithImpl<$Res, _$ServiceNotFoundImpl>
    implements _$$ServiceNotFoundImplCopyWith<$Res> {
  __$$ServiceNotFoundImplCopyWithImpl(
      _$ServiceNotFoundImpl _value, $Res Function(_$ServiceNotFoundImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$ServiceNotFoundImpl extends _ServiceNotFound {
  const _$ServiceNotFoundImpl() : super._();

  @override
  String toString() {
    return 'Failure.serviceNotFound()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$ServiceNotFoundImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() loggedOut,
    required TResult Function() network,
    required TResult Function(DateTime? cooldownEndDate) quotaExceeded,
    required TResult Function() serviceNotFound,
    required TResult Function() serviceAlreadyExists,
    required TResult Function() insufficientFunds,
    required TResult Function() unauthorized,
    required TResult Function() invalidValue,
    required TResult Function(Object? cause, StackTrace? stack) other,
  }) {
    return serviceNotFound();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? loggedOut,
    TResult? Function()? network,
    TResult? Function(DateTime? cooldownEndDate)? quotaExceeded,
    TResult? Function()? serviceNotFound,
    TResult? Function()? serviceAlreadyExists,
    TResult? Function()? insufficientFunds,
    TResult? Function()? unauthorized,
    TResult? Function()? invalidValue,
    TResult? Function(Object? cause, StackTrace? stack)? other,
  }) {
    return serviceNotFound?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? loggedOut,
    TResult Function()? network,
    TResult Function(DateTime? cooldownEndDate)? quotaExceeded,
    TResult Function()? serviceNotFound,
    TResult Function()? serviceAlreadyExists,
    TResult Function()? insufficientFunds,
    TResult Function()? unauthorized,
    TResult Function()? invalidValue,
    TResult Function(Object? cause, StackTrace? stack)? other,
    required TResult orElse(),
  }) {
    if (serviceNotFound != null) {
      return serviceNotFound();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_LoggedOut value) loggedOut,
    required TResult Function(_NetworkFailure value) network,
    required TResult Function(_QuotaExceededFailure value) quotaExceeded,
    required TResult Function(_ServiceNotFound value) serviceNotFound,
    required TResult Function(_ServiceAlreadyExists value) serviceAlreadyExists,
    required TResult Function(_InsuffientFunds value) insufficientFunds,
    required TResult Function(_Inauthorized value) unauthorized,
    required TResult Function(_InvalidValue value) invalidValue,
    required TResult Function(_OtherFailure value) other,
  }) {
    return serviceNotFound(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_LoggedOut value)? loggedOut,
    TResult? Function(_NetworkFailure value)? network,
    TResult? Function(_QuotaExceededFailure value)? quotaExceeded,
    TResult? Function(_ServiceNotFound value)? serviceNotFound,
    TResult? Function(_ServiceAlreadyExists value)? serviceAlreadyExists,
    TResult? Function(_InsuffientFunds value)? insufficientFunds,
    TResult? Function(_Inauthorized value)? unauthorized,
    TResult? Function(_InvalidValue value)? invalidValue,
    TResult? Function(_OtherFailure value)? other,
  }) {
    return serviceNotFound?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_LoggedOut value)? loggedOut,
    TResult Function(_NetworkFailure value)? network,
    TResult Function(_QuotaExceededFailure value)? quotaExceeded,
    TResult Function(_ServiceNotFound value)? serviceNotFound,
    TResult Function(_ServiceAlreadyExists value)? serviceAlreadyExists,
    TResult Function(_InsuffientFunds value)? insufficientFunds,
    TResult Function(_Inauthorized value)? unauthorized,
    TResult Function(_InvalidValue value)? invalidValue,
    TResult Function(_OtherFailure value)? other,
    required TResult orElse(),
  }) {
    if (serviceNotFound != null) {
      return serviceNotFound(this);
    }
    return orElse();
  }
}

abstract class _ServiceNotFound extends Failure {
  const factory _ServiceNotFound() = _$ServiceNotFoundImpl;
  const _ServiceNotFound._() : super._();
}

/// @nodoc
abstract class _$$ServiceAlreadyExistsImplCopyWith<$Res> {
  factory _$$ServiceAlreadyExistsImplCopyWith(_$ServiceAlreadyExistsImpl value,
          $Res Function(_$ServiceAlreadyExistsImpl) then) =
      __$$ServiceAlreadyExistsImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$ServiceAlreadyExistsImplCopyWithImpl<$Res>
    extends _$FailureCopyWithImpl<$Res, _$ServiceAlreadyExistsImpl>
    implements _$$ServiceAlreadyExistsImplCopyWith<$Res> {
  __$$ServiceAlreadyExistsImplCopyWithImpl(_$ServiceAlreadyExistsImpl _value,
      $Res Function(_$ServiceAlreadyExistsImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$ServiceAlreadyExistsImpl extends _ServiceAlreadyExists {
  const _$ServiceAlreadyExistsImpl() : super._();

  @override
  String toString() {
    return 'Failure.serviceAlreadyExists()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ServiceAlreadyExistsImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() loggedOut,
    required TResult Function() network,
    required TResult Function(DateTime? cooldownEndDate) quotaExceeded,
    required TResult Function() serviceNotFound,
    required TResult Function() serviceAlreadyExists,
    required TResult Function() insufficientFunds,
    required TResult Function() unauthorized,
    required TResult Function() invalidValue,
    required TResult Function(Object? cause, StackTrace? stack) other,
  }) {
    return serviceAlreadyExists();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? loggedOut,
    TResult? Function()? network,
    TResult? Function(DateTime? cooldownEndDate)? quotaExceeded,
    TResult? Function()? serviceNotFound,
    TResult? Function()? serviceAlreadyExists,
    TResult? Function()? insufficientFunds,
    TResult? Function()? unauthorized,
    TResult? Function()? invalidValue,
    TResult? Function(Object? cause, StackTrace? stack)? other,
  }) {
    return serviceAlreadyExists?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? loggedOut,
    TResult Function()? network,
    TResult Function(DateTime? cooldownEndDate)? quotaExceeded,
    TResult Function()? serviceNotFound,
    TResult Function()? serviceAlreadyExists,
    TResult Function()? insufficientFunds,
    TResult Function()? unauthorized,
    TResult Function()? invalidValue,
    TResult Function(Object? cause, StackTrace? stack)? other,
    required TResult orElse(),
  }) {
    if (serviceAlreadyExists != null) {
      return serviceAlreadyExists();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_LoggedOut value) loggedOut,
    required TResult Function(_NetworkFailure value) network,
    required TResult Function(_QuotaExceededFailure value) quotaExceeded,
    required TResult Function(_ServiceNotFound value) serviceNotFound,
    required TResult Function(_ServiceAlreadyExists value) serviceAlreadyExists,
    required TResult Function(_InsuffientFunds value) insufficientFunds,
    required TResult Function(_Inauthorized value) unauthorized,
    required TResult Function(_InvalidValue value) invalidValue,
    required TResult Function(_OtherFailure value) other,
  }) {
    return serviceAlreadyExists(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_LoggedOut value)? loggedOut,
    TResult? Function(_NetworkFailure value)? network,
    TResult? Function(_QuotaExceededFailure value)? quotaExceeded,
    TResult? Function(_ServiceNotFound value)? serviceNotFound,
    TResult? Function(_ServiceAlreadyExists value)? serviceAlreadyExists,
    TResult? Function(_InsuffientFunds value)? insufficientFunds,
    TResult? Function(_Inauthorized value)? unauthorized,
    TResult? Function(_InvalidValue value)? invalidValue,
    TResult? Function(_OtherFailure value)? other,
  }) {
    return serviceAlreadyExists?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_LoggedOut value)? loggedOut,
    TResult Function(_NetworkFailure value)? network,
    TResult Function(_QuotaExceededFailure value)? quotaExceeded,
    TResult Function(_ServiceNotFound value)? serviceNotFound,
    TResult Function(_ServiceAlreadyExists value)? serviceAlreadyExists,
    TResult Function(_InsuffientFunds value)? insufficientFunds,
    TResult Function(_Inauthorized value)? unauthorized,
    TResult Function(_InvalidValue value)? invalidValue,
    TResult Function(_OtherFailure value)? other,
    required TResult orElse(),
  }) {
    if (serviceAlreadyExists != null) {
      return serviceAlreadyExists(this);
    }
    return orElse();
  }
}

abstract class _ServiceAlreadyExists extends Failure {
  const factory _ServiceAlreadyExists() = _$ServiceAlreadyExistsImpl;
  const _ServiceAlreadyExists._() : super._();
}

/// @nodoc
abstract class _$$InsuffientFundsImplCopyWith<$Res> {
  factory _$$InsuffientFundsImplCopyWith(_$InsuffientFundsImpl value,
          $Res Function(_$InsuffientFundsImpl) then) =
      __$$InsuffientFundsImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$InsuffientFundsImplCopyWithImpl<$Res>
    extends _$FailureCopyWithImpl<$Res, _$InsuffientFundsImpl>
    implements _$$InsuffientFundsImplCopyWith<$Res> {
  __$$InsuffientFundsImplCopyWithImpl(
      _$InsuffientFundsImpl _value, $Res Function(_$InsuffientFundsImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$InsuffientFundsImpl extends _InsuffientFunds {
  const _$InsuffientFundsImpl() : super._();

  @override
  String toString() {
    return 'Failure.insufficientFunds()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$InsuffientFundsImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() loggedOut,
    required TResult Function() network,
    required TResult Function(DateTime? cooldownEndDate) quotaExceeded,
    required TResult Function() serviceNotFound,
    required TResult Function() serviceAlreadyExists,
    required TResult Function() insufficientFunds,
    required TResult Function() unauthorized,
    required TResult Function() invalidValue,
    required TResult Function(Object? cause, StackTrace? stack) other,
  }) {
    return insufficientFunds();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? loggedOut,
    TResult? Function()? network,
    TResult? Function(DateTime? cooldownEndDate)? quotaExceeded,
    TResult? Function()? serviceNotFound,
    TResult? Function()? serviceAlreadyExists,
    TResult? Function()? insufficientFunds,
    TResult? Function()? unauthorized,
    TResult? Function()? invalidValue,
    TResult? Function(Object? cause, StackTrace? stack)? other,
  }) {
    return insufficientFunds?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? loggedOut,
    TResult Function()? network,
    TResult Function(DateTime? cooldownEndDate)? quotaExceeded,
    TResult Function()? serviceNotFound,
    TResult Function()? serviceAlreadyExists,
    TResult Function()? insufficientFunds,
    TResult Function()? unauthorized,
    TResult Function()? invalidValue,
    TResult Function(Object? cause, StackTrace? stack)? other,
    required TResult orElse(),
  }) {
    if (insufficientFunds != null) {
      return insufficientFunds();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_LoggedOut value) loggedOut,
    required TResult Function(_NetworkFailure value) network,
    required TResult Function(_QuotaExceededFailure value) quotaExceeded,
    required TResult Function(_ServiceNotFound value) serviceNotFound,
    required TResult Function(_ServiceAlreadyExists value) serviceAlreadyExists,
    required TResult Function(_InsuffientFunds value) insufficientFunds,
    required TResult Function(_Inauthorized value) unauthorized,
    required TResult Function(_InvalidValue value) invalidValue,
    required TResult Function(_OtherFailure value) other,
  }) {
    return insufficientFunds(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_LoggedOut value)? loggedOut,
    TResult? Function(_NetworkFailure value)? network,
    TResult? Function(_QuotaExceededFailure value)? quotaExceeded,
    TResult? Function(_ServiceNotFound value)? serviceNotFound,
    TResult? Function(_ServiceAlreadyExists value)? serviceAlreadyExists,
    TResult? Function(_InsuffientFunds value)? insufficientFunds,
    TResult? Function(_Inauthorized value)? unauthorized,
    TResult? Function(_InvalidValue value)? invalidValue,
    TResult? Function(_OtherFailure value)? other,
  }) {
    return insufficientFunds?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_LoggedOut value)? loggedOut,
    TResult Function(_NetworkFailure value)? network,
    TResult Function(_QuotaExceededFailure value)? quotaExceeded,
    TResult Function(_ServiceNotFound value)? serviceNotFound,
    TResult Function(_ServiceAlreadyExists value)? serviceAlreadyExists,
    TResult Function(_InsuffientFunds value)? insufficientFunds,
    TResult Function(_Inauthorized value)? unauthorized,
    TResult Function(_InvalidValue value)? invalidValue,
    TResult Function(_OtherFailure value)? other,
    required TResult orElse(),
  }) {
    if (insufficientFunds != null) {
      return insufficientFunds(this);
    }
    return orElse();
  }
}

abstract class _InsuffientFunds extends Failure {
  const factory _InsuffientFunds() = _$InsuffientFundsImpl;
  const _InsuffientFunds._() : super._();
}

/// @nodoc
abstract class _$$InauthorizedImplCopyWith<$Res> {
  factory _$$InauthorizedImplCopyWith(
          _$InauthorizedImpl value, $Res Function(_$InauthorizedImpl) then) =
      __$$InauthorizedImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$InauthorizedImplCopyWithImpl<$Res>
    extends _$FailureCopyWithImpl<$Res, _$InauthorizedImpl>
    implements _$$InauthorizedImplCopyWith<$Res> {
  __$$InauthorizedImplCopyWithImpl(
      _$InauthorizedImpl _value, $Res Function(_$InauthorizedImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$InauthorizedImpl extends _Inauthorized {
  const _$InauthorizedImpl() : super._();

  @override
  String toString() {
    return 'Failure.unauthorized()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$InauthorizedImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() loggedOut,
    required TResult Function() network,
    required TResult Function(DateTime? cooldownEndDate) quotaExceeded,
    required TResult Function() serviceNotFound,
    required TResult Function() serviceAlreadyExists,
    required TResult Function() insufficientFunds,
    required TResult Function() unauthorized,
    required TResult Function() invalidValue,
    required TResult Function(Object? cause, StackTrace? stack) other,
  }) {
    return unauthorized();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? loggedOut,
    TResult? Function()? network,
    TResult? Function(DateTime? cooldownEndDate)? quotaExceeded,
    TResult? Function()? serviceNotFound,
    TResult? Function()? serviceAlreadyExists,
    TResult? Function()? insufficientFunds,
    TResult? Function()? unauthorized,
    TResult? Function()? invalidValue,
    TResult? Function(Object? cause, StackTrace? stack)? other,
  }) {
    return unauthorized?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? loggedOut,
    TResult Function()? network,
    TResult Function(DateTime? cooldownEndDate)? quotaExceeded,
    TResult Function()? serviceNotFound,
    TResult Function()? serviceAlreadyExists,
    TResult Function()? insufficientFunds,
    TResult Function()? unauthorized,
    TResult Function()? invalidValue,
    TResult Function(Object? cause, StackTrace? stack)? other,
    required TResult orElse(),
  }) {
    if (unauthorized != null) {
      return unauthorized();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_LoggedOut value) loggedOut,
    required TResult Function(_NetworkFailure value) network,
    required TResult Function(_QuotaExceededFailure value) quotaExceeded,
    required TResult Function(_ServiceNotFound value) serviceNotFound,
    required TResult Function(_ServiceAlreadyExists value) serviceAlreadyExists,
    required TResult Function(_InsuffientFunds value) insufficientFunds,
    required TResult Function(_Inauthorized value) unauthorized,
    required TResult Function(_InvalidValue value) invalidValue,
    required TResult Function(_OtherFailure value) other,
  }) {
    return unauthorized(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_LoggedOut value)? loggedOut,
    TResult? Function(_NetworkFailure value)? network,
    TResult? Function(_QuotaExceededFailure value)? quotaExceeded,
    TResult? Function(_ServiceNotFound value)? serviceNotFound,
    TResult? Function(_ServiceAlreadyExists value)? serviceAlreadyExists,
    TResult? Function(_InsuffientFunds value)? insufficientFunds,
    TResult? Function(_Inauthorized value)? unauthorized,
    TResult? Function(_InvalidValue value)? invalidValue,
    TResult? Function(_OtherFailure value)? other,
  }) {
    return unauthorized?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_LoggedOut value)? loggedOut,
    TResult Function(_NetworkFailure value)? network,
    TResult Function(_QuotaExceededFailure value)? quotaExceeded,
    TResult Function(_ServiceNotFound value)? serviceNotFound,
    TResult Function(_ServiceAlreadyExists value)? serviceAlreadyExists,
    TResult Function(_InsuffientFunds value)? insufficientFunds,
    TResult Function(_Inauthorized value)? unauthorized,
    TResult Function(_InvalidValue value)? invalidValue,
    TResult Function(_OtherFailure value)? other,
    required TResult orElse(),
  }) {
    if (unauthorized != null) {
      return unauthorized(this);
    }
    return orElse();
  }
}

abstract class _Inauthorized extends Failure {
  const factory _Inauthorized() = _$InauthorizedImpl;
  const _Inauthorized._() : super._();
}

/// @nodoc
abstract class _$$InvalidValueImplCopyWith<$Res> {
  factory _$$InvalidValueImplCopyWith(
          _$InvalidValueImpl value, $Res Function(_$InvalidValueImpl) then) =
      __$$InvalidValueImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$InvalidValueImplCopyWithImpl<$Res>
    extends _$FailureCopyWithImpl<$Res, _$InvalidValueImpl>
    implements _$$InvalidValueImplCopyWith<$Res> {
  __$$InvalidValueImplCopyWithImpl(
      _$InvalidValueImpl _value, $Res Function(_$InvalidValueImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$InvalidValueImpl extends _InvalidValue {
  const _$InvalidValueImpl() : super._();

  @override
  String toString() {
    return 'Failure.invalidValue()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$InvalidValueImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() loggedOut,
    required TResult Function() network,
    required TResult Function(DateTime? cooldownEndDate) quotaExceeded,
    required TResult Function() serviceNotFound,
    required TResult Function() serviceAlreadyExists,
    required TResult Function() insufficientFunds,
    required TResult Function() unauthorized,
    required TResult Function() invalidValue,
    required TResult Function(Object? cause, StackTrace? stack) other,
  }) {
    return invalidValue();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? loggedOut,
    TResult? Function()? network,
    TResult? Function(DateTime? cooldownEndDate)? quotaExceeded,
    TResult? Function()? serviceNotFound,
    TResult? Function()? serviceAlreadyExists,
    TResult? Function()? insufficientFunds,
    TResult? Function()? unauthorized,
    TResult? Function()? invalidValue,
    TResult? Function(Object? cause, StackTrace? stack)? other,
  }) {
    return invalidValue?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? loggedOut,
    TResult Function()? network,
    TResult Function(DateTime? cooldownEndDate)? quotaExceeded,
    TResult Function()? serviceNotFound,
    TResult Function()? serviceAlreadyExists,
    TResult Function()? insufficientFunds,
    TResult Function()? unauthorized,
    TResult Function()? invalidValue,
    TResult Function(Object? cause, StackTrace? stack)? other,
    required TResult orElse(),
  }) {
    if (invalidValue != null) {
      return invalidValue();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_LoggedOut value) loggedOut,
    required TResult Function(_NetworkFailure value) network,
    required TResult Function(_QuotaExceededFailure value) quotaExceeded,
    required TResult Function(_ServiceNotFound value) serviceNotFound,
    required TResult Function(_ServiceAlreadyExists value) serviceAlreadyExists,
    required TResult Function(_InsuffientFunds value) insufficientFunds,
    required TResult Function(_Inauthorized value) unauthorized,
    required TResult Function(_InvalidValue value) invalidValue,
    required TResult Function(_OtherFailure value) other,
  }) {
    return invalidValue(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_LoggedOut value)? loggedOut,
    TResult? Function(_NetworkFailure value)? network,
    TResult? Function(_QuotaExceededFailure value)? quotaExceeded,
    TResult? Function(_ServiceNotFound value)? serviceNotFound,
    TResult? Function(_ServiceAlreadyExists value)? serviceAlreadyExists,
    TResult? Function(_InsuffientFunds value)? insufficientFunds,
    TResult? Function(_Inauthorized value)? unauthorized,
    TResult? Function(_InvalidValue value)? invalidValue,
    TResult? Function(_OtherFailure value)? other,
  }) {
    return invalidValue?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_LoggedOut value)? loggedOut,
    TResult Function(_NetworkFailure value)? network,
    TResult Function(_QuotaExceededFailure value)? quotaExceeded,
    TResult Function(_ServiceNotFound value)? serviceNotFound,
    TResult Function(_ServiceAlreadyExists value)? serviceAlreadyExists,
    TResult Function(_InsuffientFunds value)? insufficientFunds,
    TResult Function(_Inauthorized value)? unauthorized,
    TResult Function(_InvalidValue value)? invalidValue,
    TResult Function(_OtherFailure value)? other,
    required TResult orElse(),
  }) {
    if (invalidValue != null) {
      return invalidValue(this);
    }
    return orElse();
  }
}

abstract class _InvalidValue extends Failure {
  const factory _InvalidValue() = _$InvalidValueImpl;
  const _InvalidValue._() : super._();
}

/// @nodoc
abstract class _$$OtherFailureImplCopyWith<$Res> {
  factory _$$OtherFailureImplCopyWith(
          _$OtherFailureImpl value, $Res Function(_$OtherFailureImpl) then) =
      __$$OtherFailureImplCopyWithImpl<$Res>;
  @useResult
  $Res call({Object? cause, StackTrace? stack});
}

/// @nodoc
class __$$OtherFailureImplCopyWithImpl<$Res>
    extends _$FailureCopyWithImpl<$Res, _$OtherFailureImpl>
    implements _$$OtherFailureImplCopyWith<$Res> {
  __$$OtherFailureImplCopyWithImpl(
      _$OtherFailureImpl _value, $Res Function(_$OtherFailureImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? cause = freezed,
    Object? stack = freezed,
  }) {
    return _then(_$OtherFailureImpl(
      cause: freezed == cause ? _value.cause : cause,
      stack: freezed == stack
          ? _value.stack
          : stack // ignore: cast_nullable_to_non_nullable
              as StackTrace?,
    ));
  }
}

/// @nodoc

class _$OtherFailureImpl extends _OtherFailure {
  const _$OtherFailureImpl({this.cause, this.stack}) : super._();

  @override
  final Object? cause;
  @override
  final StackTrace? stack;

  @override
  String toString() {
    return 'Failure.other(cause: $cause, stack: $stack)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$OtherFailureImpl &&
            const DeepCollectionEquality().equals(other.cause, cause) &&
            (identical(other.stack, stack) || other.stack == stack));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, const DeepCollectionEquality().hash(cause), stack);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$OtherFailureImplCopyWith<_$OtherFailureImpl> get copyWith =>
      __$$OtherFailureImplCopyWithImpl<_$OtherFailureImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() loggedOut,
    required TResult Function() network,
    required TResult Function(DateTime? cooldownEndDate) quotaExceeded,
    required TResult Function() serviceNotFound,
    required TResult Function() serviceAlreadyExists,
    required TResult Function() insufficientFunds,
    required TResult Function() unauthorized,
    required TResult Function() invalidValue,
    required TResult Function(Object? cause, StackTrace? stack) other,
  }) {
    return other(cause, stack);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? loggedOut,
    TResult? Function()? network,
    TResult? Function(DateTime? cooldownEndDate)? quotaExceeded,
    TResult? Function()? serviceNotFound,
    TResult? Function()? serviceAlreadyExists,
    TResult? Function()? insufficientFunds,
    TResult? Function()? unauthorized,
    TResult? Function()? invalidValue,
    TResult? Function(Object? cause, StackTrace? stack)? other,
  }) {
    return other?.call(cause, stack);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? loggedOut,
    TResult Function()? network,
    TResult Function(DateTime? cooldownEndDate)? quotaExceeded,
    TResult Function()? serviceNotFound,
    TResult Function()? serviceAlreadyExists,
    TResult Function()? insufficientFunds,
    TResult Function()? unauthorized,
    TResult Function()? invalidValue,
    TResult Function(Object? cause, StackTrace? stack)? other,
    required TResult orElse(),
  }) {
    if (other != null) {
      return other(cause, stack);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_LoggedOut value) loggedOut,
    required TResult Function(_NetworkFailure value) network,
    required TResult Function(_QuotaExceededFailure value) quotaExceeded,
    required TResult Function(_ServiceNotFound value) serviceNotFound,
    required TResult Function(_ServiceAlreadyExists value) serviceAlreadyExists,
    required TResult Function(_InsuffientFunds value) insufficientFunds,
    required TResult Function(_Inauthorized value) unauthorized,
    required TResult Function(_InvalidValue value) invalidValue,
    required TResult Function(_OtherFailure value) other,
  }) {
    return other(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_LoggedOut value)? loggedOut,
    TResult? Function(_NetworkFailure value)? network,
    TResult? Function(_QuotaExceededFailure value)? quotaExceeded,
    TResult? Function(_ServiceNotFound value)? serviceNotFound,
    TResult? Function(_ServiceAlreadyExists value)? serviceAlreadyExists,
    TResult? Function(_InsuffientFunds value)? insufficientFunds,
    TResult? Function(_Inauthorized value)? unauthorized,
    TResult? Function(_InvalidValue value)? invalidValue,
    TResult? Function(_OtherFailure value)? other,
  }) {
    return other?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_LoggedOut value)? loggedOut,
    TResult Function(_NetworkFailure value)? network,
    TResult Function(_QuotaExceededFailure value)? quotaExceeded,
    TResult Function(_ServiceNotFound value)? serviceNotFound,
    TResult Function(_ServiceAlreadyExists value)? serviceAlreadyExists,
    TResult Function(_InsuffientFunds value)? insufficientFunds,
    TResult Function(_Inauthorized value)? unauthorized,
    TResult Function(_InvalidValue value)? invalidValue,
    TResult Function(_OtherFailure value)? other,
    required TResult orElse(),
  }) {
    if (other != null) {
      return other(this);
    }
    return orElse();
  }
}

abstract class _OtherFailure extends Failure {
  const factory _OtherFailure({final Object? cause, final StackTrace? stack}) =
      _$OtherFailureImpl;
  const _OtherFailure._() : super._();

  Object? get cause;
  StackTrace? get stack;
  @JsonKey(ignore: true)
  _$$OtherFailureImplCopyWith<_$OtherFailureImpl> get copyWith =>
      throw _privateConstructorUsedError;
}
