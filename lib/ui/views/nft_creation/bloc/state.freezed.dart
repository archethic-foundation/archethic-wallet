// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'state.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

/// @nodoc
mixin _$NftCreationFormState {
  NftCreationProcessStep get nftCreationProcessStep =>
      throw _privateConstructorUsedError;
  int get indexTab => throw _privateConstructorUsedError;
  AsyncValue<double> get feeEstimation => throw _privateConstructorUsedError;
  AccountBalance get accountBalance => throw _privateConstructorUsedError;
  Map<Uint8List, List<String>>? get file => throw _privateConstructorUsedError;
  FileImportType? get fileImportType => throw _privateConstructorUsedError;
  Uint8List? get fileDecoded => throw _privateConstructorUsedError;
  Uint8List? get fileDecodedForPreview => throw _privateConstructorUsedError;
  String? get fileTypeMime => throw _privateConstructorUsedError;
  int get fileSize => throw _privateConstructorUsedError;
  String get name => throw _privateConstructorUsedError;
  String get description => throw _privateConstructorUsedError;
  String get propertyName => throw _privateConstructorUsedError;
  String get propertyValue => throw _privateConstructorUsedError;
  String get propertySearch => throw _privateConstructorUsedError;
  String? get fileURL => throw _privateConstructorUsedError;
  PropertyAccessRecipient get propertyAccessRecipient =>
      throw _privateConstructorUsedError;
  List<NftCreationFormStateProperty> get properties =>
      throw _privateConstructorUsedError;
  String get error => throw _privateConstructorUsedError;
  String get symbol => throw _privateConstructorUsedError;
  int get initialSupply => throw _privateConstructorUsedError;
  bool get checkPreventUserPublicInfo => throw _privateConstructorUsedError;
  Transaction? get transaction => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $NftCreationFormStateCopyWith<NftCreationFormState> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $NftCreationFormStateCopyWith<$Res> {
  factory $NftCreationFormStateCopyWith(NftCreationFormState value,
          $Res Function(NftCreationFormState) then) =
      _$NftCreationFormStateCopyWithImpl<$Res, NftCreationFormState>;
  @useResult
  $Res call(
      {NftCreationProcessStep nftCreationProcessStep,
      int indexTab,
      AsyncValue<double> feeEstimation,
      AccountBalance accountBalance,
      Map<Uint8List, List<String>>? file,
      FileImportType? fileImportType,
      Uint8List? fileDecoded,
      Uint8List? fileDecodedForPreview,
      String? fileTypeMime,
      int fileSize,
      String name,
      String description,
      String propertyName,
      String propertyValue,
      String propertySearch,
      String? fileURL,
      PropertyAccessRecipient propertyAccessRecipient,
      List<NftCreationFormStateProperty> properties,
      String error,
      String symbol,
      int initialSupply,
      bool checkPreventUserPublicInfo,
      Transaction? transaction});

  $PropertyAccessRecipientCopyWith<$Res> get propertyAccessRecipient;
  $TransactionCopyWith<$Res>? get transaction;
}

/// @nodoc
class _$NftCreationFormStateCopyWithImpl<$Res,
        $Val extends NftCreationFormState>
    implements $NftCreationFormStateCopyWith<$Res> {
  _$NftCreationFormStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? nftCreationProcessStep = null,
    Object? indexTab = null,
    Object? feeEstimation = null,
    Object? accountBalance = null,
    Object? file = freezed,
    Object? fileImportType = freezed,
    Object? fileDecoded = freezed,
    Object? fileDecodedForPreview = freezed,
    Object? fileTypeMime = freezed,
    Object? fileSize = null,
    Object? name = null,
    Object? description = null,
    Object? propertyName = null,
    Object? propertyValue = null,
    Object? propertySearch = null,
    Object? fileURL = freezed,
    Object? propertyAccessRecipient = null,
    Object? properties = null,
    Object? error = null,
    Object? symbol = null,
    Object? initialSupply = null,
    Object? checkPreventUserPublicInfo = null,
    Object? transaction = freezed,
  }) {
    return _then(_value.copyWith(
      nftCreationProcessStep: null == nftCreationProcessStep
          ? _value.nftCreationProcessStep
          : nftCreationProcessStep // ignore: cast_nullable_to_non_nullable
              as NftCreationProcessStep,
      indexTab: null == indexTab
          ? _value.indexTab
          : indexTab // ignore: cast_nullable_to_non_nullable
              as int,
      feeEstimation: null == feeEstimation
          ? _value.feeEstimation
          : feeEstimation // ignore: cast_nullable_to_non_nullable
              as AsyncValue<double>,
      accountBalance: null == accountBalance
          ? _value.accountBalance
          : accountBalance // ignore: cast_nullable_to_non_nullable
              as AccountBalance,
      file: freezed == file
          ? _value.file
          : file // ignore: cast_nullable_to_non_nullable
              as Map<Uint8List, List<String>>?,
      fileImportType: freezed == fileImportType
          ? _value.fileImportType
          : fileImportType // ignore: cast_nullable_to_non_nullable
              as FileImportType?,
      fileDecoded: freezed == fileDecoded
          ? _value.fileDecoded
          : fileDecoded // ignore: cast_nullable_to_non_nullable
              as Uint8List?,
      fileDecodedForPreview: freezed == fileDecodedForPreview
          ? _value.fileDecodedForPreview
          : fileDecodedForPreview // ignore: cast_nullable_to_non_nullable
              as Uint8List?,
      fileTypeMime: freezed == fileTypeMime
          ? _value.fileTypeMime
          : fileTypeMime // ignore: cast_nullable_to_non_nullable
              as String?,
      fileSize: null == fileSize
          ? _value.fileSize
          : fileSize // ignore: cast_nullable_to_non_nullable
              as int,
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      description: null == description
          ? _value.description
          : description // ignore: cast_nullable_to_non_nullable
              as String,
      propertyName: null == propertyName
          ? _value.propertyName
          : propertyName // ignore: cast_nullable_to_non_nullable
              as String,
      propertyValue: null == propertyValue
          ? _value.propertyValue
          : propertyValue // ignore: cast_nullable_to_non_nullable
              as String,
      propertySearch: null == propertySearch
          ? _value.propertySearch
          : propertySearch // ignore: cast_nullable_to_non_nullable
              as String,
      fileURL: freezed == fileURL
          ? _value.fileURL
          : fileURL // ignore: cast_nullable_to_non_nullable
              as String?,
      propertyAccessRecipient: null == propertyAccessRecipient
          ? _value.propertyAccessRecipient
          : propertyAccessRecipient // ignore: cast_nullable_to_non_nullable
              as PropertyAccessRecipient,
      properties: null == properties
          ? _value.properties
          : properties // ignore: cast_nullable_to_non_nullable
              as List<NftCreationFormStateProperty>,
      error: null == error
          ? _value.error
          : error // ignore: cast_nullable_to_non_nullable
              as String,
      symbol: null == symbol
          ? _value.symbol
          : symbol // ignore: cast_nullable_to_non_nullable
              as String,
      initialSupply: null == initialSupply
          ? _value.initialSupply
          : initialSupply // ignore: cast_nullable_to_non_nullable
              as int,
      checkPreventUserPublicInfo: null == checkPreventUserPublicInfo
          ? _value.checkPreventUserPublicInfo
          : checkPreventUserPublicInfo // ignore: cast_nullable_to_non_nullable
              as bool,
      transaction: freezed == transaction
          ? _value.transaction
          : transaction // ignore: cast_nullable_to_non_nullable
              as Transaction?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $PropertyAccessRecipientCopyWith<$Res> get propertyAccessRecipient {
    return $PropertyAccessRecipientCopyWith<$Res>(
        _value.propertyAccessRecipient, (value) {
      return _then(_value.copyWith(propertyAccessRecipient: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $TransactionCopyWith<$Res>? get transaction {
    if (_value.transaction == null) {
      return null;
    }

    return $TransactionCopyWith<$Res>(_value.transaction!, (value) {
      return _then(_value.copyWith(transaction: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$NftCreationFormStateImplCopyWith<$Res>
    implements $NftCreationFormStateCopyWith<$Res> {
  factory _$$NftCreationFormStateImplCopyWith(_$NftCreationFormStateImpl value,
          $Res Function(_$NftCreationFormStateImpl) then) =
      __$$NftCreationFormStateImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {NftCreationProcessStep nftCreationProcessStep,
      int indexTab,
      AsyncValue<double> feeEstimation,
      AccountBalance accountBalance,
      Map<Uint8List, List<String>>? file,
      FileImportType? fileImportType,
      Uint8List? fileDecoded,
      Uint8List? fileDecodedForPreview,
      String? fileTypeMime,
      int fileSize,
      String name,
      String description,
      String propertyName,
      String propertyValue,
      String propertySearch,
      String? fileURL,
      PropertyAccessRecipient propertyAccessRecipient,
      List<NftCreationFormStateProperty> properties,
      String error,
      String symbol,
      int initialSupply,
      bool checkPreventUserPublicInfo,
      Transaction? transaction});

  @override
  $PropertyAccessRecipientCopyWith<$Res> get propertyAccessRecipient;
  @override
  $TransactionCopyWith<$Res>? get transaction;
}

/// @nodoc
class __$$NftCreationFormStateImplCopyWithImpl<$Res>
    extends _$NftCreationFormStateCopyWithImpl<$Res, _$NftCreationFormStateImpl>
    implements _$$NftCreationFormStateImplCopyWith<$Res> {
  __$$NftCreationFormStateImplCopyWithImpl(_$NftCreationFormStateImpl _value,
      $Res Function(_$NftCreationFormStateImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? nftCreationProcessStep = null,
    Object? indexTab = null,
    Object? feeEstimation = null,
    Object? accountBalance = null,
    Object? file = freezed,
    Object? fileImportType = freezed,
    Object? fileDecoded = freezed,
    Object? fileDecodedForPreview = freezed,
    Object? fileTypeMime = freezed,
    Object? fileSize = null,
    Object? name = null,
    Object? description = null,
    Object? propertyName = null,
    Object? propertyValue = null,
    Object? propertySearch = null,
    Object? fileURL = freezed,
    Object? propertyAccessRecipient = null,
    Object? properties = null,
    Object? error = null,
    Object? symbol = null,
    Object? initialSupply = null,
    Object? checkPreventUserPublicInfo = null,
    Object? transaction = freezed,
  }) {
    return _then(_$NftCreationFormStateImpl(
      nftCreationProcessStep: null == nftCreationProcessStep
          ? _value.nftCreationProcessStep
          : nftCreationProcessStep // ignore: cast_nullable_to_non_nullable
              as NftCreationProcessStep,
      indexTab: null == indexTab
          ? _value.indexTab
          : indexTab // ignore: cast_nullable_to_non_nullable
              as int,
      feeEstimation: null == feeEstimation
          ? _value.feeEstimation
          : feeEstimation // ignore: cast_nullable_to_non_nullable
              as AsyncValue<double>,
      accountBalance: null == accountBalance
          ? _value.accountBalance
          : accountBalance // ignore: cast_nullable_to_non_nullable
              as AccountBalance,
      file: freezed == file
          ? _value._file
          : file // ignore: cast_nullable_to_non_nullable
              as Map<Uint8List, List<String>>?,
      fileImportType: freezed == fileImportType
          ? _value.fileImportType
          : fileImportType // ignore: cast_nullable_to_non_nullable
              as FileImportType?,
      fileDecoded: freezed == fileDecoded
          ? _value.fileDecoded
          : fileDecoded // ignore: cast_nullable_to_non_nullable
              as Uint8List?,
      fileDecodedForPreview: freezed == fileDecodedForPreview
          ? _value.fileDecodedForPreview
          : fileDecodedForPreview // ignore: cast_nullable_to_non_nullable
              as Uint8List?,
      fileTypeMime: freezed == fileTypeMime
          ? _value.fileTypeMime
          : fileTypeMime // ignore: cast_nullable_to_non_nullable
              as String?,
      fileSize: null == fileSize
          ? _value.fileSize
          : fileSize // ignore: cast_nullable_to_non_nullable
              as int,
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      description: null == description
          ? _value.description
          : description // ignore: cast_nullable_to_non_nullable
              as String,
      propertyName: null == propertyName
          ? _value.propertyName
          : propertyName // ignore: cast_nullable_to_non_nullable
              as String,
      propertyValue: null == propertyValue
          ? _value.propertyValue
          : propertyValue // ignore: cast_nullable_to_non_nullable
              as String,
      propertySearch: null == propertySearch
          ? _value.propertySearch
          : propertySearch // ignore: cast_nullable_to_non_nullable
              as String,
      fileURL: freezed == fileURL
          ? _value.fileURL
          : fileURL // ignore: cast_nullable_to_non_nullable
              as String?,
      propertyAccessRecipient: null == propertyAccessRecipient
          ? _value.propertyAccessRecipient
          : propertyAccessRecipient // ignore: cast_nullable_to_non_nullable
              as PropertyAccessRecipient,
      properties: null == properties
          ? _value._properties
          : properties // ignore: cast_nullable_to_non_nullable
              as List<NftCreationFormStateProperty>,
      error: null == error
          ? _value.error
          : error // ignore: cast_nullable_to_non_nullable
              as String,
      symbol: null == symbol
          ? _value.symbol
          : symbol // ignore: cast_nullable_to_non_nullable
              as String,
      initialSupply: null == initialSupply
          ? _value.initialSupply
          : initialSupply // ignore: cast_nullable_to_non_nullable
              as int,
      checkPreventUserPublicInfo: null == checkPreventUserPublicInfo
          ? _value.checkPreventUserPublicInfo
          : checkPreventUserPublicInfo // ignore: cast_nullable_to_non_nullable
              as bool,
      transaction: freezed == transaction
          ? _value.transaction
          : transaction // ignore: cast_nullable_to_non_nullable
              as Transaction?,
    ));
  }
}

/// @nodoc

class _$NftCreationFormStateImpl extends _NftCreationFormState {
  const _$NftCreationFormStateImpl(
      {this.nftCreationProcessStep = NftCreationProcessStep.form,
      this.indexTab = 0,
      required this.feeEstimation,
      required this.accountBalance,
      final Map<Uint8List, List<String>>? file,
      this.fileImportType,
      this.fileDecoded,
      this.fileDecodedForPreview,
      this.fileTypeMime = '',
      this.fileSize = 0,
      this.name = '',
      this.description = '',
      this.propertyName = '',
      this.propertyValue = '',
      this.propertySearch = '',
      this.fileURL,
      required this.propertyAccessRecipient,
      final List<NftCreationFormStateProperty> properties = const [],
      this.error = '',
      this.symbol = '',
      this.initialSupply = 1,
      this.checkPreventUserPublicInfo = false,
      this.transaction})
      : _file = file,
        _properties = properties,
        super._();

  @override
  @JsonKey()
  final NftCreationProcessStep nftCreationProcessStep;
  @override
  @JsonKey()
  final int indexTab;
  @override
  final AsyncValue<double> feeEstimation;
  @override
  final AccountBalance accountBalance;
  final Map<Uint8List, List<String>>? _file;
  @override
  Map<Uint8List, List<String>>? get file {
    final value = _file;
    if (value == null) return null;
    if (_file is EqualUnmodifiableMapView) return _file;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(value);
  }

  @override
  final FileImportType? fileImportType;
  @override
  final Uint8List? fileDecoded;
  @override
  final Uint8List? fileDecodedForPreview;
  @override
  @JsonKey()
  final String? fileTypeMime;
  @override
  @JsonKey()
  final int fileSize;
  @override
  @JsonKey()
  final String name;
  @override
  @JsonKey()
  final String description;
  @override
  @JsonKey()
  final String propertyName;
  @override
  @JsonKey()
  final String propertyValue;
  @override
  @JsonKey()
  final String propertySearch;
  @override
  final String? fileURL;
  @override
  final PropertyAccessRecipient propertyAccessRecipient;
  final List<NftCreationFormStateProperty> _properties;
  @override
  @JsonKey()
  List<NftCreationFormStateProperty> get properties {
    if (_properties is EqualUnmodifiableListView) return _properties;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_properties);
  }

  @override
  @JsonKey()
  final String error;
  @override
  @JsonKey()
  final String symbol;
  @override
  @JsonKey()
  final int initialSupply;
  @override
  @JsonKey()
  final bool checkPreventUserPublicInfo;
  @override
  final Transaction? transaction;

  @override
  String toString() {
    return 'NftCreationFormState(nftCreationProcessStep: $nftCreationProcessStep, indexTab: $indexTab, feeEstimation: $feeEstimation, accountBalance: $accountBalance, file: $file, fileImportType: $fileImportType, fileDecoded: $fileDecoded, fileDecodedForPreview: $fileDecodedForPreview, fileTypeMime: $fileTypeMime, fileSize: $fileSize, name: $name, description: $description, propertyName: $propertyName, propertyValue: $propertyValue, propertySearch: $propertySearch, fileURL: $fileURL, propertyAccessRecipient: $propertyAccessRecipient, properties: $properties, error: $error, symbol: $symbol, initialSupply: $initialSupply, checkPreventUserPublicInfo: $checkPreventUserPublicInfo, transaction: $transaction)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$NftCreationFormStateImpl &&
            (identical(other.nftCreationProcessStep, nftCreationProcessStep) ||
                other.nftCreationProcessStep == nftCreationProcessStep) &&
            (identical(other.indexTab, indexTab) ||
                other.indexTab == indexTab) &&
            (identical(other.feeEstimation, feeEstimation) ||
                other.feeEstimation == feeEstimation) &&
            (identical(other.accountBalance, accountBalance) ||
                other.accountBalance == accountBalance) &&
            const DeepCollectionEquality().equals(other._file, _file) &&
            (identical(other.fileImportType, fileImportType) ||
                other.fileImportType == fileImportType) &&
            const DeepCollectionEquality()
                .equals(other.fileDecoded, fileDecoded) &&
            const DeepCollectionEquality()
                .equals(other.fileDecodedForPreview, fileDecodedForPreview) &&
            (identical(other.fileTypeMime, fileTypeMime) ||
                other.fileTypeMime == fileTypeMime) &&
            (identical(other.fileSize, fileSize) ||
                other.fileSize == fileSize) &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.description, description) ||
                other.description == description) &&
            (identical(other.propertyName, propertyName) ||
                other.propertyName == propertyName) &&
            (identical(other.propertyValue, propertyValue) ||
                other.propertyValue == propertyValue) &&
            (identical(other.propertySearch, propertySearch) ||
                other.propertySearch == propertySearch) &&
            (identical(other.fileURL, fileURL) || other.fileURL == fileURL) &&
            (identical(
                    other.propertyAccessRecipient, propertyAccessRecipient) ||
                other.propertyAccessRecipient == propertyAccessRecipient) &&
            const DeepCollectionEquality()
                .equals(other._properties, _properties) &&
            (identical(other.error, error) || other.error == error) &&
            (identical(other.symbol, symbol) || other.symbol == symbol) &&
            (identical(other.initialSupply, initialSupply) ||
                other.initialSupply == initialSupply) &&
            (identical(other.checkPreventUserPublicInfo,
                    checkPreventUserPublicInfo) ||
                other.checkPreventUserPublicInfo ==
                    checkPreventUserPublicInfo) &&
            (identical(other.transaction, transaction) ||
                other.transaction == transaction));
  }

  @override
  int get hashCode => Object.hashAll([
        runtimeType,
        nftCreationProcessStep,
        indexTab,
        feeEstimation,
        accountBalance,
        const DeepCollectionEquality().hash(_file),
        fileImportType,
        const DeepCollectionEquality().hash(fileDecoded),
        const DeepCollectionEquality().hash(fileDecodedForPreview),
        fileTypeMime,
        fileSize,
        name,
        description,
        propertyName,
        propertyValue,
        propertySearch,
        fileURL,
        propertyAccessRecipient,
        const DeepCollectionEquality().hash(_properties),
        error,
        symbol,
        initialSupply,
        checkPreventUserPublicInfo,
        transaction
      ]);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$NftCreationFormStateImplCopyWith<_$NftCreationFormStateImpl>
      get copyWith =>
          __$$NftCreationFormStateImplCopyWithImpl<_$NftCreationFormStateImpl>(
              this, _$identity);
}

abstract class _NftCreationFormState extends NftCreationFormState {
  const factory _NftCreationFormState(
      {final NftCreationProcessStep nftCreationProcessStep,
      final int indexTab,
      required final AsyncValue<double> feeEstimation,
      required final AccountBalance accountBalance,
      final Map<Uint8List, List<String>>? file,
      final FileImportType? fileImportType,
      final Uint8List? fileDecoded,
      final Uint8List? fileDecodedForPreview,
      final String? fileTypeMime,
      final int fileSize,
      final String name,
      final String description,
      final String propertyName,
      final String propertyValue,
      final String propertySearch,
      final String? fileURL,
      required final PropertyAccessRecipient propertyAccessRecipient,
      final List<NftCreationFormStateProperty> properties,
      final String error,
      final String symbol,
      final int initialSupply,
      final bool checkPreventUserPublicInfo,
      final Transaction? transaction}) = _$NftCreationFormStateImpl;
  const _NftCreationFormState._() : super._();

  @override
  NftCreationProcessStep get nftCreationProcessStep;
  @override
  int get indexTab;
  @override
  AsyncValue<double> get feeEstimation;
  @override
  AccountBalance get accountBalance;
  @override
  Map<Uint8List, List<String>>? get file;
  @override
  FileImportType? get fileImportType;
  @override
  Uint8List? get fileDecoded;
  @override
  Uint8List? get fileDecodedForPreview;
  @override
  String? get fileTypeMime;
  @override
  int get fileSize;
  @override
  String get name;
  @override
  String get description;
  @override
  String get propertyName;
  @override
  String get propertyValue;
  @override
  String get propertySearch;
  @override
  String? get fileURL;
  @override
  PropertyAccessRecipient get propertyAccessRecipient;
  @override
  List<NftCreationFormStateProperty> get properties;
  @override
  String get error;
  @override
  String get symbol;
  @override
  int get initialSupply;
  @override
  bool get checkPreventUserPublicInfo;
  @override
  Transaction? get transaction;
  @override
  @JsonKey(ignore: true)
  _$$NftCreationFormStateImplCopyWith<_$NftCreationFormStateImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$NftCreationFormStateProperty {
  String get propertyName => throw _privateConstructorUsedError;
  dynamic get propertyValue => throw _privateConstructorUsedError;
  List<PropertyAccessRecipient> get addresses =>
      throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $NftCreationFormStatePropertyCopyWith<NftCreationFormStateProperty>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $NftCreationFormStatePropertyCopyWith<$Res> {
  factory $NftCreationFormStatePropertyCopyWith(
          NftCreationFormStateProperty value,
          $Res Function(NftCreationFormStateProperty) then) =
      _$NftCreationFormStatePropertyCopyWithImpl<$Res,
          NftCreationFormStateProperty>;
  @useResult
  $Res call(
      {String propertyName,
      dynamic propertyValue,
      List<PropertyAccessRecipient> addresses});
}

/// @nodoc
class _$NftCreationFormStatePropertyCopyWithImpl<$Res,
        $Val extends NftCreationFormStateProperty>
    implements $NftCreationFormStatePropertyCopyWith<$Res> {
  _$NftCreationFormStatePropertyCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? propertyName = null,
    Object? propertyValue = freezed,
    Object? addresses = null,
  }) {
    return _then(_value.copyWith(
      propertyName: null == propertyName
          ? _value.propertyName
          : propertyName // ignore: cast_nullable_to_non_nullable
              as String,
      propertyValue: freezed == propertyValue
          ? _value.propertyValue
          : propertyValue // ignore: cast_nullable_to_non_nullable
              as dynamic,
      addresses: null == addresses
          ? _value.addresses
          : addresses // ignore: cast_nullable_to_non_nullable
              as List<PropertyAccessRecipient>,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$NftCreationFormStatePropertyImplCopyWith<$Res>
    implements $NftCreationFormStatePropertyCopyWith<$Res> {
  factory _$$NftCreationFormStatePropertyImplCopyWith(
          _$NftCreationFormStatePropertyImpl value,
          $Res Function(_$NftCreationFormStatePropertyImpl) then) =
      __$$NftCreationFormStatePropertyImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String propertyName,
      dynamic propertyValue,
      List<PropertyAccessRecipient> addresses});
}

/// @nodoc
class __$$NftCreationFormStatePropertyImplCopyWithImpl<$Res>
    extends _$NftCreationFormStatePropertyCopyWithImpl<$Res,
        _$NftCreationFormStatePropertyImpl>
    implements _$$NftCreationFormStatePropertyImplCopyWith<$Res> {
  __$$NftCreationFormStatePropertyImplCopyWithImpl(
      _$NftCreationFormStatePropertyImpl _value,
      $Res Function(_$NftCreationFormStatePropertyImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? propertyName = null,
    Object? propertyValue = freezed,
    Object? addresses = null,
  }) {
    return _then(_$NftCreationFormStatePropertyImpl(
      propertyName: null == propertyName
          ? _value.propertyName
          : propertyName // ignore: cast_nullable_to_non_nullable
              as String,
      propertyValue: freezed == propertyValue
          ? _value.propertyValue
          : propertyValue // ignore: cast_nullable_to_non_nullable
              as dynamic,
      addresses: null == addresses
          ? _value._addresses
          : addresses // ignore: cast_nullable_to_non_nullable
              as List<PropertyAccessRecipient>,
    ));
  }
}

/// @nodoc

class _$NftCreationFormStatePropertyImpl extends _NftCreationFormStateProperty {
  const _$NftCreationFormStatePropertyImpl(
      {this.propertyName = '',
      this.propertyValue,
      final List<PropertyAccessRecipient> addresses = const []})
      : _addresses = addresses,
        super._();

  @override
  @JsonKey()
  final String propertyName;
  @override
  final dynamic propertyValue;
  final List<PropertyAccessRecipient> _addresses;
  @override
  @JsonKey()
  List<PropertyAccessRecipient> get addresses {
    if (_addresses is EqualUnmodifiableListView) return _addresses;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_addresses);
  }

  @override
  String toString() {
    return 'NftCreationFormStateProperty(propertyName: $propertyName, propertyValue: $propertyValue, addresses: $addresses)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$NftCreationFormStatePropertyImpl &&
            (identical(other.propertyName, propertyName) ||
                other.propertyName == propertyName) &&
            const DeepCollectionEquality()
                .equals(other.propertyValue, propertyValue) &&
            const DeepCollectionEquality()
                .equals(other._addresses, _addresses));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      propertyName,
      const DeepCollectionEquality().hash(propertyValue),
      const DeepCollectionEquality().hash(_addresses));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$NftCreationFormStatePropertyImplCopyWith<
          _$NftCreationFormStatePropertyImpl>
      get copyWith => __$$NftCreationFormStatePropertyImplCopyWithImpl<
          _$NftCreationFormStatePropertyImpl>(this, _$identity);
}

abstract class _NftCreationFormStateProperty
    extends NftCreationFormStateProperty {
  const factory _NftCreationFormStateProperty(
          {final String propertyName,
          final dynamic propertyValue,
          final List<PropertyAccessRecipient> addresses}) =
      _$NftCreationFormStatePropertyImpl;
  const _NftCreationFormStateProperty._() : super._();

  @override
  String get propertyName;
  @override
  dynamic get propertyValue;
  @override
  List<PropertyAccessRecipient> get addresses;
  @override
  @JsonKey(ignore: true)
  _$$NftCreationFormStatePropertyImplCopyWith<
          _$NftCreationFormStatePropertyImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$PropertyAccessRecipient {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(Address address) address,
    required TResult Function(Contact contact) contact,
    required TResult Function(String name) unknownContact,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(Address address)? address,
    TResult? Function(Contact contact)? contact,
    TResult? Function(String name)? unknownContact,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(Address address)? address,
    TResult Function(Contact contact)? contact,
    TResult Function(String name)? unknownContact,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_PropertyAccessAddress value) address,
    required TResult Function(_PropertyAccessContact value) contact,
    required TResult Function(_PropertyAccessUnknownContact value)
        unknownContact,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_PropertyAccessAddress value)? address,
    TResult? Function(_PropertyAccessContact value)? contact,
    TResult? Function(_PropertyAccessUnknownContact value)? unknownContact,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_PropertyAccessAddress value)? address,
    TResult Function(_PropertyAccessContact value)? contact,
    TResult Function(_PropertyAccessUnknownContact value)? unknownContact,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $PropertyAccessRecipientCopyWith<$Res> {
  factory $PropertyAccessRecipientCopyWith(PropertyAccessRecipient value,
          $Res Function(PropertyAccessRecipient) then) =
      _$PropertyAccessRecipientCopyWithImpl<$Res, PropertyAccessRecipient>;
}

/// @nodoc
class _$PropertyAccessRecipientCopyWithImpl<$Res,
        $Val extends PropertyAccessRecipient>
    implements $PropertyAccessRecipientCopyWith<$Res> {
  _$PropertyAccessRecipientCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$PropertyAccessAddressImplCopyWith<$Res> {
  factory _$$PropertyAccessAddressImplCopyWith(
          _$PropertyAccessAddressImpl value,
          $Res Function(_$PropertyAccessAddressImpl) then) =
      __$$PropertyAccessAddressImplCopyWithImpl<$Res>;
  @useResult
  $Res call({Address address});

  $AddressCopyWith<$Res> get address;
}

/// @nodoc
class __$$PropertyAccessAddressImplCopyWithImpl<$Res>
    extends _$PropertyAccessRecipientCopyWithImpl<$Res,
        _$PropertyAccessAddressImpl>
    implements _$$PropertyAccessAddressImplCopyWith<$Res> {
  __$$PropertyAccessAddressImplCopyWithImpl(_$PropertyAccessAddressImpl _value,
      $Res Function(_$PropertyAccessAddressImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? address = null,
  }) {
    return _then(_$PropertyAccessAddressImpl(
      address: null == address
          ? _value.address
          : address // ignore: cast_nullable_to_non_nullable
              as Address,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $AddressCopyWith<$Res> get address {
    return $AddressCopyWith<$Res>(_value.address, (value) {
      return _then(_value.copyWith(address: value));
    });
  }
}

/// @nodoc

class _$PropertyAccessAddressImpl extends _PropertyAccessAddress {
  const _$PropertyAccessAddressImpl({required this.address}) : super._();

  @override
  final Address address;

  @override
  String toString() {
    return 'PropertyAccessRecipient.address(address: $address)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$PropertyAccessAddressImpl &&
            (identical(other.address, address) || other.address == address));
  }

  @override
  int get hashCode => Object.hash(runtimeType, address);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$PropertyAccessAddressImplCopyWith<_$PropertyAccessAddressImpl>
      get copyWith => __$$PropertyAccessAddressImplCopyWithImpl<
          _$PropertyAccessAddressImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(Address address) address,
    required TResult Function(Contact contact) contact,
    required TResult Function(String name) unknownContact,
  }) {
    return address(this.address);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(Address address)? address,
    TResult? Function(Contact contact)? contact,
    TResult? Function(String name)? unknownContact,
  }) {
    return address?.call(this.address);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(Address address)? address,
    TResult Function(Contact contact)? contact,
    TResult Function(String name)? unknownContact,
    required TResult orElse(),
  }) {
    if (address != null) {
      return address(this.address);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_PropertyAccessAddress value) address,
    required TResult Function(_PropertyAccessContact value) contact,
    required TResult Function(_PropertyAccessUnknownContact value)
        unknownContact,
  }) {
    return address(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_PropertyAccessAddress value)? address,
    TResult? Function(_PropertyAccessContact value)? contact,
    TResult? Function(_PropertyAccessUnknownContact value)? unknownContact,
  }) {
    return address?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_PropertyAccessAddress value)? address,
    TResult Function(_PropertyAccessContact value)? contact,
    TResult Function(_PropertyAccessUnknownContact value)? unknownContact,
    required TResult orElse(),
  }) {
    if (address != null) {
      return address(this);
    }
    return orElse();
  }
}

abstract class _PropertyAccessAddress extends PropertyAccessRecipient {
  const factory _PropertyAccessAddress({required final Address address}) =
      _$PropertyAccessAddressImpl;
  const _PropertyAccessAddress._() : super._();

  Address get address;
  @JsonKey(ignore: true)
  _$$PropertyAccessAddressImplCopyWith<_$PropertyAccessAddressImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$PropertyAccessContactImplCopyWith<$Res> {
  factory _$$PropertyAccessContactImplCopyWith(
          _$PropertyAccessContactImpl value,
          $Res Function(_$PropertyAccessContactImpl) then) =
      __$$PropertyAccessContactImplCopyWithImpl<$Res>;
  @useResult
  $Res call({Contact contact});
}

/// @nodoc
class __$$PropertyAccessContactImplCopyWithImpl<$Res>
    extends _$PropertyAccessRecipientCopyWithImpl<$Res,
        _$PropertyAccessContactImpl>
    implements _$$PropertyAccessContactImplCopyWith<$Res> {
  __$$PropertyAccessContactImplCopyWithImpl(_$PropertyAccessContactImpl _value,
      $Res Function(_$PropertyAccessContactImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? contact = null,
  }) {
    return _then(_$PropertyAccessContactImpl(
      contact: null == contact
          ? _value.contact
          : contact // ignore: cast_nullable_to_non_nullable
              as Contact,
    ));
  }
}

/// @nodoc

class _$PropertyAccessContactImpl extends _PropertyAccessContact {
  const _$PropertyAccessContactImpl({required this.contact}) : super._();

  @override
  final Contact contact;

  @override
  String toString() {
    return 'PropertyAccessRecipient.contact(contact: $contact)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$PropertyAccessContactImpl &&
            (identical(other.contact, contact) || other.contact == contact));
  }

  @override
  int get hashCode => Object.hash(runtimeType, contact);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$PropertyAccessContactImplCopyWith<_$PropertyAccessContactImpl>
      get copyWith => __$$PropertyAccessContactImplCopyWithImpl<
          _$PropertyAccessContactImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(Address address) address,
    required TResult Function(Contact contact) contact,
    required TResult Function(String name) unknownContact,
  }) {
    return contact(this.contact);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(Address address)? address,
    TResult? Function(Contact contact)? contact,
    TResult? Function(String name)? unknownContact,
  }) {
    return contact?.call(this.contact);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(Address address)? address,
    TResult Function(Contact contact)? contact,
    TResult Function(String name)? unknownContact,
    required TResult orElse(),
  }) {
    if (contact != null) {
      return contact(this.contact);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_PropertyAccessAddress value) address,
    required TResult Function(_PropertyAccessContact value) contact,
    required TResult Function(_PropertyAccessUnknownContact value)
        unknownContact,
  }) {
    return contact(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_PropertyAccessAddress value)? address,
    TResult? Function(_PropertyAccessContact value)? contact,
    TResult? Function(_PropertyAccessUnknownContact value)? unknownContact,
  }) {
    return contact?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_PropertyAccessAddress value)? address,
    TResult Function(_PropertyAccessContact value)? contact,
    TResult Function(_PropertyAccessUnknownContact value)? unknownContact,
    required TResult orElse(),
  }) {
    if (contact != null) {
      return contact(this);
    }
    return orElse();
  }
}

abstract class _PropertyAccessContact extends PropertyAccessRecipient {
  const factory _PropertyAccessContact({required final Contact contact}) =
      _$PropertyAccessContactImpl;
  const _PropertyAccessContact._() : super._();

  Contact get contact;
  @JsonKey(ignore: true)
  _$$PropertyAccessContactImplCopyWith<_$PropertyAccessContactImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$PropertyAccessUnknownContactImplCopyWith<$Res> {
  factory _$$PropertyAccessUnknownContactImplCopyWith(
          _$PropertyAccessUnknownContactImpl value,
          $Res Function(_$PropertyAccessUnknownContactImpl) then) =
      __$$PropertyAccessUnknownContactImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String name});
}

/// @nodoc
class __$$PropertyAccessUnknownContactImplCopyWithImpl<$Res>
    extends _$PropertyAccessRecipientCopyWithImpl<$Res,
        _$PropertyAccessUnknownContactImpl>
    implements _$$PropertyAccessUnknownContactImplCopyWith<$Res> {
  __$$PropertyAccessUnknownContactImplCopyWithImpl(
      _$PropertyAccessUnknownContactImpl _value,
      $Res Function(_$PropertyAccessUnknownContactImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? name = null,
  }) {
    return _then(_$PropertyAccessUnknownContactImpl(
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$PropertyAccessUnknownContactImpl extends _PropertyAccessUnknownContact {
  const _$PropertyAccessUnknownContactImpl({required this.name}) : super._();

  @override
  final String name;

  @override
  String toString() {
    return 'PropertyAccessRecipient.unknownContact(name: $name)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$PropertyAccessUnknownContactImpl &&
            (identical(other.name, name) || other.name == name));
  }

  @override
  int get hashCode => Object.hash(runtimeType, name);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$PropertyAccessUnknownContactImplCopyWith<
          _$PropertyAccessUnknownContactImpl>
      get copyWith => __$$PropertyAccessUnknownContactImplCopyWithImpl<
          _$PropertyAccessUnknownContactImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(Address address) address,
    required TResult Function(Contact contact) contact,
    required TResult Function(String name) unknownContact,
  }) {
    return unknownContact(name);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(Address address)? address,
    TResult? Function(Contact contact)? contact,
    TResult? Function(String name)? unknownContact,
  }) {
    return unknownContact?.call(name);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(Address address)? address,
    TResult Function(Contact contact)? contact,
    TResult Function(String name)? unknownContact,
    required TResult orElse(),
  }) {
    if (unknownContact != null) {
      return unknownContact(name);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_PropertyAccessAddress value) address,
    required TResult Function(_PropertyAccessContact value) contact,
    required TResult Function(_PropertyAccessUnknownContact value)
        unknownContact,
  }) {
    return unknownContact(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_PropertyAccessAddress value)? address,
    TResult? Function(_PropertyAccessContact value)? contact,
    TResult? Function(_PropertyAccessUnknownContact value)? unknownContact,
  }) {
    return unknownContact?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_PropertyAccessAddress value)? address,
    TResult Function(_PropertyAccessContact value)? contact,
    TResult Function(_PropertyAccessUnknownContact value)? unknownContact,
    required TResult orElse(),
  }) {
    if (unknownContact != null) {
      return unknownContact(this);
    }
    return orElse();
  }
}

abstract class _PropertyAccessUnknownContact extends PropertyAccessRecipient {
  const factory _PropertyAccessUnknownContact({required final String name}) =
      _$PropertyAccessUnknownContactImpl;
  const _PropertyAccessUnknownContact._() : super._();

  String get name;
  @JsonKey(ignore: true)
  _$$PropertyAccessUnknownContactImplCopyWith<
          _$PropertyAccessUnknownContactImpl>
      get copyWith => throw _privateConstructorUsedError;
}
