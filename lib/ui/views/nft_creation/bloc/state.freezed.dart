// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target

part of 'state.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
mixin _$NftCreationFormState {
  String get seed => throw _privateConstructorUsedError;
  NftCreationProcessStep get nftCreationProcessStep =>
      throw _privateConstructorUsedError;
  int get currentNftCategoryIndex => throw _privateConstructorUsedError;
  int get indexTab => throw _privateConstructorUsedError;
  AsyncValue<double> get feeEstimation => throw _privateConstructorUsedError;
  AccountBalance get accountBalance => throw _privateConstructorUsedError;
  Map<File, List<String>>? get file => throw _privateConstructorUsedError;
  FileImportType? get fileImportType => throw _privateConstructorUsedError;
  Uint8List? get fileDecoded => throw _privateConstructorUsedError;
  Uint8List? get fileDecodedForPreview => throw _privateConstructorUsedError;
  String? get fileTypeMime => throw _privateConstructorUsedError;
  int get fileSize => throw _privateConstructorUsedError;
  String get name => throw _privateConstructorUsedError;
  String get description => throw _privateConstructorUsedError;
  String get propertyName => throw _privateConstructorUsedError;
  String get propertyValue => throw _privateConstructorUsedError;
  String get propertySearch => throw _privateConstructorUsedError;
  PropertyAccessRecipient get propertyAccessRecipient =>
      throw _privateConstructorUsedError;
  List<NftCreationFormStateProperty> get properties =>
      throw _privateConstructorUsedError;
  String get error => throw _privateConstructorUsedError;
  String get symbol => throw _privateConstructorUsedError;
  int get initialSupply => throw _privateConstructorUsedError;
  Transaction? get transaction => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $NftCreationFormStateCopyWith<NftCreationFormState> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $NftCreationFormStateCopyWith<$Res> {
  factory $NftCreationFormStateCopyWith(NftCreationFormState value,
          $Res Function(NftCreationFormState) then) =
      _$NftCreationFormStateCopyWithImpl<$Res, NftCreationFormState>;
  @useResult
  $Res call(
      {String seed,
      NftCreationProcessStep nftCreationProcessStep,
      int currentNftCategoryIndex,
      int indexTab,
      AsyncValue<double> feeEstimation,
      AccountBalance accountBalance,
      Map<File, List<String>>? file,
      FileImportType? fileImportType,
      Uint8List? fileDecoded,
      Uint8List? fileDecodedForPreview,
      String? fileTypeMime,
      int fileSize,
      String name,
      String description,
      String propertyName,
      String propertyValue,
      String propertySearch,
      PropertyAccessRecipient propertyAccessRecipient,
      List<NftCreationFormStateProperty> properties,
      String error,
      String symbol,
      int initialSupply,
      Transaction? transaction});

  $PropertyAccessRecipientCopyWith<$Res> get propertyAccessRecipient;
}

/// @nodoc
class _$NftCreationFormStateCopyWithImpl<$Res,
        $Val extends NftCreationFormState>
    implements $NftCreationFormStateCopyWith<$Res> {
  _$NftCreationFormStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? seed = null,
    Object? nftCreationProcessStep = null,
    Object? currentNftCategoryIndex = null,
    Object? indexTab = null,
    Object? feeEstimation = null,
    Object? accountBalance = null,
    Object? file = freezed,
    Object? fileImportType = freezed,
    Object? fileDecoded = freezed,
    Object? fileDecodedForPreview = freezed,
    Object? fileTypeMime = freezed,
    Object? fileSize = null,
    Object? name = null,
    Object? description = null,
    Object? propertyName = null,
    Object? propertyValue = null,
    Object? propertySearch = null,
    Object? propertyAccessRecipient = null,
    Object? properties = null,
    Object? error = null,
    Object? symbol = null,
    Object? initialSupply = null,
    Object? transaction = freezed,
  }) {
    return _then(_value.copyWith(
      seed: null == seed
          ? _value.seed
          : seed // ignore: cast_nullable_to_non_nullable
              as String,
      nftCreationProcessStep: null == nftCreationProcessStep
          ? _value.nftCreationProcessStep
          : nftCreationProcessStep // ignore: cast_nullable_to_non_nullable
              as NftCreationProcessStep,
      currentNftCategoryIndex: null == currentNftCategoryIndex
          ? _value.currentNftCategoryIndex
          : currentNftCategoryIndex // ignore: cast_nullable_to_non_nullable
              as int,
      indexTab: null == indexTab
          ? _value.indexTab
          : indexTab // ignore: cast_nullable_to_non_nullable
              as int,
      feeEstimation: null == feeEstimation
          ? _value.feeEstimation
          : feeEstimation // ignore: cast_nullable_to_non_nullable
              as AsyncValue<double>,
      accountBalance: null == accountBalance
          ? _value.accountBalance
          : accountBalance // ignore: cast_nullable_to_non_nullable
              as AccountBalance,
      file: freezed == file
          ? _value.file
          : file // ignore: cast_nullable_to_non_nullable
              as Map<File, List<String>>?,
      fileImportType: freezed == fileImportType
          ? _value.fileImportType
          : fileImportType // ignore: cast_nullable_to_non_nullable
              as FileImportType?,
      fileDecoded: freezed == fileDecoded
          ? _value.fileDecoded
          : fileDecoded // ignore: cast_nullable_to_non_nullable
              as Uint8List?,
      fileDecodedForPreview: freezed == fileDecodedForPreview
          ? _value.fileDecodedForPreview
          : fileDecodedForPreview // ignore: cast_nullable_to_non_nullable
              as Uint8List?,
      fileTypeMime: freezed == fileTypeMime
          ? _value.fileTypeMime
          : fileTypeMime // ignore: cast_nullable_to_non_nullable
              as String?,
      fileSize: null == fileSize
          ? _value.fileSize
          : fileSize // ignore: cast_nullable_to_non_nullable
              as int,
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      description: null == description
          ? _value.description
          : description // ignore: cast_nullable_to_non_nullable
              as String,
      propertyName: null == propertyName
          ? _value.propertyName
          : propertyName // ignore: cast_nullable_to_non_nullable
              as String,
      propertyValue: null == propertyValue
          ? _value.propertyValue
          : propertyValue // ignore: cast_nullable_to_non_nullable
              as String,
      propertySearch: null == propertySearch
          ? _value.propertySearch
          : propertySearch // ignore: cast_nullable_to_non_nullable
              as String,
      propertyAccessRecipient: null == propertyAccessRecipient
          ? _value.propertyAccessRecipient
          : propertyAccessRecipient // ignore: cast_nullable_to_non_nullable
              as PropertyAccessRecipient,
      properties: null == properties
          ? _value.properties
          : properties // ignore: cast_nullable_to_non_nullable
              as List<NftCreationFormStateProperty>,
      error: null == error
          ? _value.error
          : error // ignore: cast_nullable_to_non_nullable
              as String,
      symbol: null == symbol
          ? _value.symbol
          : symbol // ignore: cast_nullable_to_non_nullable
              as String,
      initialSupply: null == initialSupply
          ? _value.initialSupply
          : initialSupply // ignore: cast_nullable_to_non_nullable
              as int,
      transaction: freezed == transaction
          ? _value.transaction
          : transaction // ignore: cast_nullable_to_non_nullable
              as Transaction?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $PropertyAccessRecipientCopyWith<$Res> get propertyAccessRecipient {
    return $PropertyAccessRecipientCopyWith<$Res>(
        _value.propertyAccessRecipient, (value) {
      return _then(_value.copyWith(propertyAccessRecipient: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$_NftCreationFormStateCopyWith<$Res>
    implements $NftCreationFormStateCopyWith<$Res> {
  factory _$$_NftCreationFormStateCopyWith(_$_NftCreationFormState value,
          $Res Function(_$_NftCreationFormState) then) =
      __$$_NftCreationFormStateCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String seed,
      NftCreationProcessStep nftCreationProcessStep,
      int currentNftCategoryIndex,
      int indexTab,
      AsyncValue<double> feeEstimation,
      AccountBalance accountBalance,
      Map<File, List<String>>? file,
      FileImportType? fileImportType,
      Uint8List? fileDecoded,
      Uint8List? fileDecodedForPreview,
      String? fileTypeMime,
      int fileSize,
      String name,
      String description,
      String propertyName,
      String propertyValue,
      String propertySearch,
      PropertyAccessRecipient propertyAccessRecipient,
      List<NftCreationFormStateProperty> properties,
      String error,
      String symbol,
      int initialSupply,
      Transaction? transaction});

  @override
  $PropertyAccessRecipientCopyWith<$Res> get propertyAccessRecipient;
}

/// @nodoc
class __$$_NftCreationFormStateCopyWithImpl<$Res>
    extends _$NftCreationFormStateCopyWithImpl<$Res, _$_NftCreationFormState>
    implements _$$_NftCreationFormStateCopyWith<$Res> {
  __$$_NftCreationFormStateCopyWithImpl(_$_NftCreationFormState _value,
      $Res Function(_$_NftCreationFormState) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? seed = null,
    Object? nftCreationProcessStep = null,
    Object? currentNftCategoryIndex = null,
    Object? indexTab = null,
    Object? feeEstimation = null,
    Object? accountBalance = null,
    Object? file = freezed,
    Object? fileImportType = freezed,
    Object? fileDecoded = freezed,
    Object? fileDecodedForPreview = freezed,
    Object? fileTypeMime = freezed,
    Object? fileSize = null,
    Object? name = null,
    Object? description = null,
    Object? propertyName = null,
    Object? propertyValue = null,
    Object? propertySearch = null,
    Object? propertyAccessRecipient = null,
    Object? properties = null,
    Object? error = null,
    Object? symbol = null,
    Object? initialSupply = null,
    Object? transaction = freezed,
  }) {
    return _then(_$_NftCreationFormState(
      seed: null == seed
          ? _value.seed
          : seed // ignore: cast_nullable_to_non_nullable
              as String,
      nftCreationProcessStep: null == nftCreationProcessStep
          ? _value.nftCreationProcessStep
          : nftCreationProcessStep // ignore: cast_nullable_to_non_nullable
              as NftCreationProcessStep,
      currentNftCategoryIndex: null == currentNftCategoryIndex
          ? _value.currentNftCategoryIndex
          : currentNftCategoryIndex // ignore: cast_nullable_to_non_nullable
              as int,
      indexTab: null == indexTab
          ? _value.indexTab
          : indexTab // ignore: cast_nullable_to_non_nullable
              as int,
      feeEstimation: null == feeEstimation
          ? _value.feeEstimation
          : feeEstimation // ignore: cast_nullable_to_non_nullable
              as AsyncValue<double>,
      accountBalance: null == accountBalance
          ? _value.accountBalance
          : accountBalance // ignore: cast_nullable_to_non_nullable
              as AccountBalance,
      file: freezed == file
          ? _value._file
          : file // ignore: cast_nullable_to_non_nullable
              as Map<File, List<String>>?,
      fileImportType: freezed == fileImportType
          ? _value.fileImportType
          : fileImportType // ignore: cast_nullable_to_non_nullable
              as FileImportType?,
      fileDecoded: freezed == fileDecoded
          ? _value.fileDecoded
          : fileDecoded // ignore: cast_nullable_to_non_nullable
              as Uint8List?,
      fileDecodedForPreview: freezed == fileDecodedForPreview
          ? _value.fileDecodedForPreview
          : fileDecodedForPreview // ignore: cast_nullable_to_non_nullable
              as Uint8List?,
      fileTypeMime: freezed == fileTypeMime
          ? _value.fileTypeMime
          : fileTypeMime // ignore: cast_nullable_to_non_nullable
              as String?,
      fileSize: null == fileSize
          ? _value.fileSize
          : fileSize // ignore: cast_nullable_to_non_nullable
              as int,
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      description: null == description
          ? _value.description
          : description // ignore: cast_nullable_to_non_nullable
              as String,
      propertyName: null == propertyName
          ? _value.propertyName
          : propertyName // ignore: cast_nullable_to_non_nullable
              as String,
      propertyValue: null == propertyValue
          ? _value.propertyValue
          : propertyValue // ignore: cast_nullable_to_non_nullable
              as String,
      propertySearch: null == propertySearch
          ? _value.propertySearch
          : propertySearch // ignore: cast_nullable_to_non_nullable
              as String,
      propertyAccessRecipient: null == propertyAccessRecipient
          ? _value.propertyAccessRecipient
          : propertyAccessRecipient // ignore: cast_nullable_to_non_nullable
              as PropertyAccessRecipient,
      properties: null == properties
          ? _value._properties
          : properties // ignore: cast_nullable_to_non_nullable
              as List<NftCreationFormStateProperty>,
      error: null == error
          ? _value.error
          : error // ignore: cast_nullable_to_non_nullable
              as String,
      symbol: null == symbol
          ? _value.symbol
          : symbol // ignore: cast_nullable_to_non_nullable
              as String,
      initialSupply: null == initialSupply
          ? _value.initialSupply
          : initialSupply // ignore: cast_nullable_to_non_nullable
              as int,
      transaction: freezed == transaction
          ? _value.transaction
          : transaction // ignore: cast_nullable_to_non_nullable
              as Transaction?,
    ));
  }
}

/// @nodoc

class _$_NftCreationFormState extends _NftCreationFormState {
  const _$_NftCreationFormState(
      {required this.seed,
      this.nftCreationProcessStep = NftCreationProcessStep.form,
      this.currentNftCategoryIndex = 0,
      this.indexTab = 0,
      required this.feeEstimation,
      required this.accountBalance,
      final Map<File, List<String>>? file,
      this.fileImportType,
      this.fileDecoded,
      this.fileDecodedForPreview,
      this.fileTypeMime = '',
      this.fileSize = 0,
      this.name = '',
      this.description = '',
      this.propertyName = '',
      this.propertyValue = '',
      this.propertySearch = '',
      required this.propertyAccessRecipient,
      final List<NftCreationFormStateProperty> properties = const [],
      this.error = '',
      this.symbol = '',
      this.initialSupply = 1,
      this.transaction})
      : _file = file,
        _properties = properties,
        super._();

  @override
  final String seed;
  @override
  @JsonKey()
  final NftCreationProcessStep nftCreationProcessStep;
  @override
  @JsonKey()
  final int currentNftCategoryIndex;
  @override
  @JsonKey()
  final int indexTab;
  @override
  final AsyncValue<double> feeEstimation;
  @override
  final AccountBalance accountBalance;
  final Map<File, List<String>>? _file;
  @override
  Map<File, List<String>>? get file {
    final value = _file;
    if (value == null) return null;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(value);
  }

  @override
  final FileImportType? fileImportType;
  @override
  final Uint8List? fileDecoded;
  @override
  final Uint8List? fileDecodedForPreview;
  @override
  @JsonKey()
  final String? fileTypeMime;
  @override
  @JsonKey()
  final int fileSize;
  @override
  @JsonKey()
  final String name;
  @override
  @JsonKey()
  final String description;
  @override
  @JsonKey()
  final String propertyName;
  @override
  @JsonKey()
  final String propertyValue;
  @override
  @JsonKey()
  final String propertySearch;
  @override
  final PropertyAccessRecipient propertyAccessRecipient;
  final List<NftCreationFormStateProperty> _properties;
  @override
  @JsonKey()
  List<NftCreationFormStateProperty> get properties {
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_properties);
  }

  @override
  @JsonKey()
  final String error;
  @override
  @JsonKey()
  final String symbol;
  @override
  @JsonKey()
  final int initialSupply;
  @override
  final Transaction? transaction;

  @override
  String toString() {
    return 'NftCreationFormState(seed: $seed, nftCreationProcessStep: $nftCreationProcessStep, currentNftCategoryIndex: $currentNftCategoryIndex, indexTab: $indexTab, feeEstimation: $feeEstimation, accountBalance: $accountBalance, file: $file, fileImportType: $fileImportType, fileDecoded: $fileDecoded, fileDecodedForPreview: $fileDecodedForPreview, fileTypeMime: $fileTypeMime, fileSize: $fileSize, name: $name, description: $description, propertyName: $propertyName, propertyValue: $propertyValue, propertySearch: $propertySearch, propertyAccessRecipient: $propertyAccessRecipient, properties: $properties, error: $error, symbol: $symbol, initialSupply: $initialSupply, transaction: $transaction)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_NftCreationFormState &&
            (identical(other.seed, seed) || other.seed == seed) &&
            (identical(other.nftCreationProcessStep, nftCreationProcessStep) ||
                other.nftCreationProcessStep == nftCreationProcessStep) &&
            (identical(
                    other.currentNftCategoryIndex, currentNftCategoryIndex) ||
                other.currentNftCategoryIndex == currentNftCategoryIndex) &&
            (identical(other.indexTab, indexTab) ||
                other.indexTab == indexTab) &&
            (identical(other.feeEstimation, feeEstimation) ||
                other.feeEstimation == feeEstimation) &&
            (identical(other.accountBalance, accountBalance) ||
                other.accountBalance == accountBalance) &&
            const DeepCollectionEquality().equals(other._file, _file) &&
            (identical(other.fileImportType, fileImportType) ||
                other.fileImportType == fileImportType) &&
            const DeepCollectionEquality()
                .equals(other.fileDecoded, fileDecoded) &&
            const DeepCollectionEquality()
                .equals(other.fileDecodedForPreview, fileDecodedForPreview) &&
            (identical(other.fileTypeMime, fileTypeMime) ||
                other.fileTypeMime == fileTypeMime) &&
            (identical(other.fileSize, fileSize) ||
                other.fileSize == fileSize) &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.description, description) ||
                other.description == description) &&
            (identical(other.propertyName, propertyName) ||
                other.propertyName == propertyName) &&
            (identical(other.propertyValue, propertyValue) ||
                other.propertyValue == propertyValue) &&
            (identical(other.propertySearch, propertySearch) ||
                other.propertySearch == propertySearch) &&
            (identical(
                    other.propertyAccessRecipient, propertyAccessRecipient) ||
                other.propertyAccessRecipient == propertyAccessRecipient) &&
            const DeepCollectionEquality()
                .equals(other._properties, _properties) &&
            (identical(other.error, error) || other.error == error) &&
            (identical(other.symbol, symbol) || other.symbol == symbol) &&
            (identical(other.initialSupply, initialSupply) ||
                other.initialSupply == initialSupply) &&
            (identical(other.transaction, transaction) ||
                other.transaction == transaction));
  }

  @override
  int get hashCode => Object.hashAll([
        runtimeType,
        seed,
        nftCreationProcessStep,
        currentNftCategoryIndex,
        indexTab,
        feeEstimation,
        accountBalance,
        const DeepCollectionEquality().hash(_file),
        fileImportType,
        const DeepCollectionEquality().hash(fileDecoded),
        const DeepCollectionEquality().hash(fileDecodedForPreview),
        fileTypeMime,
        fileSize,
        name,
        description,
        propertyName,
        propertyValue,
        propertySearch,
        propertyAccessRecipient,
        const DeepCollectionEquality().hash(_properties),
        error,
        symbol,
        initialSupply,
        transaction
      ]);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_NftCreationFormStateCopyWith<_$_NftCreationFormState> get copyWith =>
      __$$_NftCreationFormStateCopyWithImpl<_$_NftCreationFormState>(
          this, _$identity);
}

abstract class _NftCreationFormState extends NftCreationFormState {
  const factory _NftCreationFormState(
      {required final String seed,
      final NftCreationProcessStep nftCreationProcessStep,
      final int currentNftCategoryIndex,
      final int indexTab,
      required final AsyncValue<double> feeEstimation,
      required final AccountBalance accountBalance,
      final Map<File, List<String>>? file,
      final FileImportType? fileImportType,
      final Uint8List? fileDecoded,
      final Uint8List? fileDecodedForPreview,
      final String? fileTypeMime,
      final int fileSize,
      final String name,
      final String description,
      final String propertyName,
      final String propertyValue,
      final String propertySearch,
      required final PropertyAccessRecipient propertyAccessRecipient,
      final List<NftCreationFormStateProperty> properties,
      final String error,
      final String symbol,
      final int initialSupply,
      final Transaction? transaction}) = _$_NftCreationFormState;
  const _NftCreationFormState._() : super._();

  @override
  String get seed;
  @override
  NftCreationProcessStep get nftCreationProcessStep;
  @override
  int get currentNftCategoryIndex;
  @override
  int get indexTab;
  @override
  AsyncValue<double> get feeEstimation;
  @override
  AccountBalance get accountBalance;
  @override
  Map<File, List<String>>? get file;
  @override
  FileImportType? get fileImportType;
  @override
  Uint8List? get fileDecoded;
  @override
  Uint8List? get fileDecodedForPreview;
  @override
  String? get fileTypeMime;
  @override
  int get fileSize;
  @override
  String get name;
  @override
  String get description;
  @override
  String get propertyName;
  @override
  String get propertyValue;
  @override
  String get propertySearch;
  @override
  PropertyAccessRecipient get propertyAccessRecipient;
  @override
  List<NftCreationFormStateProperty> get properties;
  @override
  String get error;
  @override
  String get symbol;
  @override
  int get initialSupply;
  @override
  Transaction? get transaction;
  @override
  @JsonKey(ignore: true)
  _$$_NftCreationFormStateCopyWith<_$_NftCreationFormState> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$NftCreationFormStateProperty {
  String get propertyName => throw _privateConstructorUsedError;
  String get propertyValue => throw _privateConstructorUsedError;
  List<PropertyAccessRecipient> get publicKeys =>
      throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $NftCreationFormStatePropertyCopyWith<NftCreationFormStateProperty>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $NftCreationFormStatePropertyCopyWith<$Res> {
  factory $NftCreationFormStatePropertyCopyWith(
          NftCreationFormStateProperty value,
          $Res Function(NftCreationFormStateProperty) then) =
      _$NftCreationFormStatePropertyCopyWithImpl<$Res,
          NftCreationFormStateProperty>;
  @useResult
  $Res call(
      {String propertyName,
      String propertyValue,
      List<PropertyAccessRecipient> publicKeys});
}

/// @nodoc
class _$NftCreationFormStatePropertyCopyWithImpl<$Res,
        $Val extends NftCreationFormStateProperty>
    implements $NftCreationFormStatePropertyCopyWith<$Res> {
  _$NftCreationFormStatePropertyCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? propertyName = null,
    Object? propertyValue = null,
    Object? publicKeys = null,
  }) {
    return _then(_value.copyWith(
      propertyName: null == propertyName
          ? _value.propertyName
          : propertyName // ignore: cast_nullable_to_non_nullable
              as String,
      propertyValue: null == propertyValue
          ? _value.propertyValue
          : propertyValue // ignore: cast_nullable_to_non_nullable
              as String,
      publicKeys: null == publicKeys
          ? _value.publicKeys
          : publicKeys // ignore: cast_nullable_to_non_nullable
              as List<PropertyAccessRecipient>,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_NftCreationFormStatePropertyCopyWith<$Res>
    implements $NftCreationFormStatePropertyCopyWith<$Res> {
  factory _$$_NftCreationFormStatePropertyCopyWith(
          _$_NftCreationFormStateProperty value,
          $Res Function(_$_NftCreationFormStateProperty) then) =
      __$$_NftCreationFormStatePropertyCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String propertyName,
      String propertyValue,
      List<PropertyAccessRecipient> publicKeys});
}

/// @nodoc
class __$$_NftCreationFormStatePropertyCopyWithImpl<$Res>
    extends _$NftCreationFormStatePropertyCopyWithImpl<$Res,
        _$_NftCreationFormStateProperty>
    implements _$$_NftCreationFormStatePropertyCopyWith<$Res> {
  __$$_NftCreationFormStatePropertyCopyWithImpl(
      _$_NftCreationFormStateProperty _value,
      $Res Function(_$_NftCreationFormStateProperty) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? propertyName = null,
    Object? propertyValue = null,
    Object? publicKeys = null,
  }) {
    return _then(_$_NftCreationFormStateProperty(
      propertyName: null == propertyName
          ? _value.propertyName
          : propertyName // ignore: cast_nullable_to_non_nullable
              as String,
      propertyValue: null == propertyValue
          ? _value.propertyValue
          : propertyValue // ignore: cast_nullable_to_non_nullable
              as String,
      publicKeys: null == publicKeys
          ? _value._publicKeys
          : publicKeys // ignore: cast_nullable_to_non_nullable
              as List<PropertyAccessRecipient>,
    ));
  }
}

/// @nodoc

class _$_NftCreationFormStateProperty extends _NftCreationFormStateProperty {
  const _$_NftCreationFormStateProperty(
      {this.propertyName = '',
      this.propertyValue = '',
      final List<PropertyAccessRecipient> publicKeys = const []})
      : _publicKeys = publicKeys,
        super._();

  @override
  @JsonKey()
  final String propertyName;
  @override
  @JsonKey()
  final String propertyValue;
  final List<PropertyAccessRecipient> _publicKeys;
  @override
  @JsonKey()
  List<PropertyAccessRecipient> get publicKeys {
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_publicKeys);
  }

  @override
  String toString() {
    return 'NftCreationFormStateProperty(propertyName: $propertyName, propertyValue: $propertyValue, publicKeys: $publicKeys)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_NftCreationFormStateProperty &&
            (identical(other.propertyName, propertyName) ||
                other.propertyName == propertyName) &&
            (identical(other.propertyValue, propertyValue) ||
                other.propertyValue == propertyValue) &&
            const DeepCollectionEquality()
                .equals(other._publicKeys, _publicKeys));
  }

  @override
  int get hashCode => Object.hash(runtimeType, propertyName, propertyValue,
      const DeepCollectionEquality().hash(_publicKeys));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_NftCreationFormStatePropertyCopyWith<_$_NftCreationFormStateProperty>
      get copyWith => __$$_NftCreationFormStatePropertyCopyWithImpl<
          _$_NftCreationFormStateProperty>(this, _$identity);
}

abstract class _NftCreationFormStateProperty
    extends NftCreationFormStateProperty {
  const factory _NftCreationFormStateProperty(
          {final String propertyName,
          final String propertyValue,
          final List<PropertyAccessRecipient> publicKeys}) =
      _$_NftCreationFormStateProperty;
  const _NftCreationFormStateProperty._() : super._();

  @override
  String get propertyName;
  @override
  String get propertyValue;
  @override
  List<PropertyAccessRecipient> get publicKeys;
  @override
  @JsonKey(ignore: true)
  _$$_NftCreationFormStatePropertyCopyWith<_$_NftCreationFormStateProperty>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$PropertyAccessRecipient {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(PublicKey publicKey) publicKey,
    required TResult Function(Contact contact) contact,
    required TResult Function(String name) unknownContact,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(PublicKey publicKey)? publicKey,
    TResult? Function(Contact contact)? contact,
    TResult? Function(String name)? unknownContact,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(PublicKey publicKey)? publicKey,
    TResult Function(Contact contact)? contact,
    TResult Function(String name)? unknownContact,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_PropertyAccessPublicKey value) publicKey,
    required TResult Function(_PropertyAccessContact value) contact,
    required TResult Function(_PropertyAccessUnknownContact value)
        unknownContact,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_PropertyAccessPublicKey value)? publicKey,
    TResult? Function(_PropertyAccessContact value)? contact,
    TResult? Function(_PropertyAccessUnknownContact value)? unknownContact,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_PropertyAccessPublicKey value)? publicKey,
    TResult Function(_PropertyAccessContact value)? contact,
    TResult Function(_PropertyAccessUnknownContact value)? unknownContact,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $PropertyAccessRecipientCopyWith<$Res> {
  factory $PropertyAccessRecipientCopyWith(PropertyAccessRecipient value,
          $Res Function(PropertyAccessRecipient) then) =
      _$PropertyAccessRecipientCopyWithImpl<$Res, PropertyAccessRecipient>;
}

/// @nodoc
class _$PropertyAccessRecipientCopyWithImpl<$Res,
        $Val extends PropertyAccessRecipient>
    implements $PropertyAccessRecipientCopyWith<$Res> {
  _$PropertyAccessRecipientCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$_PropertyAccessPublicKeyCopyWith<$Res> {
  factory _$$_PropertyAccessPublicKeyCopyWith(_$_PropertyAccessPublicKey value,
          $Res Function(_$_PropertyAccessPublicKey) then) =
      __$$_PropertyAccessPublicKeyCopyWithImpl<$Res>;
  @useResult
  $Res call({PublicKey publicKey});
}

/// @nodoc
class __$$_PropertyAccessPublicKeyCopyWithImpl<$Res>
    extends _$PropertyAccessRecipientCopyWithImpl<$Res,
        _$_PropertyAccessPublicKey>
    implements _$$_PropertyAccessPublicKeyCopyWith<$Res> {
  __$$_PropertyAccessPublicKeyCopyWithImpl(_$_PropertyAccessPublicKey _value,
      $Res Function(_$_PropertyAccessPublicKey) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? publicKey = null,
  }) {
    return _then(_$_PropertyAccessPublicKey(
      publicKey: null == publicKey
          ? _value.publicKey
          : publicKey // ignore: cast_nullable_to_non_nullable
              as PublicKey,
    ));
  }
}

/// @nodoc

class _$_PropertyAccessPublicKey extends _PropertyAccessPublicKey {
  const _$_PropertyAccessPublicKey({required this.publicKey}) : super._();

  @override
  final PublicKey publicKey;

  @override
  String toString() {
    return 'PropertyAccessRecipient.publicKey(publicKey: $publicKey)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_PropertyAccessPublicKey &&
            (identical(other.publicKey, publicKey) ||
                other.publicKey == publicKey));
  }

  @override
  int get hashCode => Object.hash(runtimeType, publicKey);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_PropertyAccessPublicKeyCopyWith<_$_PropertyAccessPublicKey>
      get copyWith =>
          __$$_PropertyAccessPublicKeyCopyWithImpl<_$_PropertyAccessPublicKey>(
              this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(PublicKey publicKey) publicKey,
    required TResult Function(Contact contact) contact,
    required TResult Function(String name) unknownContact,
  }) {
    return publicKey(this.publicKey);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(PublicKey publicKey)? publicKey,
    TResult? Function(Contact contact)? contact,
    TResult? Function(String name)? unknownContact,
  }) {
    return publicKey?.call(this.publicKey);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(PublicKey publicKey)? publicKey,
    TResult Function(Contact contact)? contact,
    TResult Function(String name)? unknownContact,
    required TResult orElse(),
  }) {
    if (publicKey != null) {
      return publicKey(this.publicKey);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_PropertyAccessPublicKey value) publicKey,
    required TResult Function(_PropertyAccessContact value) contact,
    required TResult Function(_PropertyAccessUnknownContact value)
        unknownContact,
  }) {
    return publicKey(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_PropertyAccessPublicKey value)? publicKey,
    TResult? Function(_PropertyAccessContact value)? contact,
    TResult? Function(_PropertyAccessUnknownContact value)? unknownContact,
  }) {
    return publicKey?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_PropertyAccessPublicKey value)? publicKey,
    TResult Function(_PropertyAccessContact value)? contact,
    TResult Function(_PropertyAccessUnknownContact value)? unknownContact,
    required TResult orElse(),
  }) {
    if (publicKey != null) {
      return publicKey(this);
    }
    return orElse();
  }
}

abstract class _PropertyAccessPublicKey extends PropertyAccessRecipient {
  const factory _PropertyAccessPublicKey({required final PublicKey publicKey}) =
      _$_PropertyAccessPublicKey;
  const _PropertyAccessPublicKey._() : super._();

  PublicKey get publicKey;
  @JsonKey(ignore: true)
  _$$_PropertyAccessPublicKeyCopyWith<_$_PropertyAccessPublicKey>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$_PropertyAccessContactCopyWith<$Res> {
  factory _$$_PropertyAccessContactCopyWith(_$_PropertyAccessContact value,
          $Res Function(_$_PropertyAccessContact) then) =
      __$$_PropertyAccessContactCopyWithImpl<$Res>;
  @useResult
  $Res call({Contact contact});
}

/// @nodoc
class __$$_PropertyAccessContactCopyWithImpl<$Res>
    extends _$PropertyAccessRecipientCopyWithImpl<$Res,
        _$_PropertyAccessContact>
    implements _$$_PropertyAccessContactCopyWith<$Res> {
  __$$_PropertyAccessContactCopyWithImpl(_$_PropertyAccessContact _value,
      $Res Function(_$_PropertyAccessContact) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? contact = null,
  }) {
    return _then(_$_PropertyAccessContact(
      contact: null == contact
          ? _value.contact
          : contact // ignore: cast_nullable_to_non_nullable
              as Contact,
    ));
  }
}

/// @nodoc

class _$_PropertyAccessContact extends _PropertyAccessContact {
  const _$_PropertyAccessContact({required this.contact}) : super._();

  @override
  final Contact contact;

  @override
  String toString() {
    return 'PropertyAccessRecipient.contact(contact: $contact)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_PropertyAccessContact &&
            (identical(other.contact, contact) || other.contact == contact));
  }

  @override
  int get hashCode => Object.hash(runtimeType, contact);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_PropertyAccessContactCopyWith<_$_PropertyAccessContact> get copyWith =>
      __$$_PropertyAccessContactCopyWithImpl<_$_PropertyAccessContact>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(PublicKey publicKey) publicKey,
    required TResult Function(Contact contact) contact,
    required TResult Function(String name) unknownContact,
  }) {
    return contact(this.contact);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(PublicKey publicKey)? publicKey,
    TResult? Function(Contact contact)? contact,
    TResult? Function(String name)? unknownContact,
  }) {
    return contact?.call(this.contact);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(PublicKey publicKey)? publicKey,
    TResult Function(Contact contact)? contact,
    TResult Function(String name)? unknownContact,
    required TResult orElse(),
  }) {
    if (contact != null) {
      return contact(this.contact);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_PropertyAccessPublicKey value) publicKey,
    required TResult Function(_PropertyAccessContact value) contact,
    required TResult Function(_PropertyAccessUnknownContact value)
        unknownContact,
  }) {
    return contact(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_PropertyAccessPublicKey value)? publicKey,
    TResult? Function(_PropertyAccessContact value)? contact,
    TResult? Function(_PropertyAccessUnknownContact value)? unknownContact,
  }) {
    return contact?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_PropertyAccessPublicKey value)? publicKey,
    TResult Function(_PropertyAccessContact value)? contact,
    TResult Function(_PropertyAccessUnknownContact value)? unknownContact,
    required TResult orElse(),
  }) {
    if (contact != null) {
      return contact(this);
    }
    return orElse();
  }
}

abstract class _PropertyAccessContact extends PropertyAccessRecipient {
  const factory _PropertyAccessContact({required final Contact contact}) =
      _$_PropertyAccessContact;
  const _PropertyAccessContact._() : super._();

  Contact get contact;
  @JsonKey(ignore: true)
  _$$_PropertyAccessContactCopyWith<_$_PropertyAccessContact> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$_PropertyAccessUnknownContactCopyWith<$Res> {
  factory _$$_PropertyAccessUnknownContactCopyWith(
          _$_PropertyAccessUnknownContact value,
          $Res Function(_$_PropertyAccessUnknownContact) then) =
      __$$_PropertyAccessUnknownContactCopyWithImpl<$Res>;
  @useResult
  $Res call({String name});
}

/// @nodoc
class __$$_PropertyAccessUnknownContactCopyWithImpl<$Res>
    extends _$PropertyAccessRecipientCopyWithImpl<$Res,
        _$_PropertyAccessUnknownContact>
    implements _$$_PropertyAccessUnknownContactCopyWith<$Res> {
  __$$_PropertyAccessUnknownContactCopyWithImpl(
      _$_PropertyAccessUnknownContact _value,
      $Res Function(_$_PropertyAccessUnknownContact) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? name = null,
  }) {
    return _then(_$_PropertyAccessUnknownContact(
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$_PropertyAccessUnknownContact extends _PropertyAccessUnknownContact {
  const _$_PropertyAccessUnknownContact({required this.name}) : super._();

  @override
  final String name;

  @override
  String toString() {
    return 'PropertyAccessRecipient.unknownContact(name: $name)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_PropertyAccessUnknownContact &&
            (identical(other.name, name) || other.name == name));
  }

  @override
  int get hashCode => Object.hash(runtimeType, name);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_PropertyAccessUnknownContactCopyWith<_$_PropertyAccessUnknownContact>
      get copyWith => __$$_PropertyAccessUnknownContactCopyWithImpl<
          _$_PropertyAccessUnknownContact>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(PublicKey publicKey) publicKey,
    required TResult Function(Contact contact) contact,
    required TResult Function(String name) unknownContact,
  }) {
    return unknownContact(name);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(PublicKey publicKey)? publicKey,
    TResult? Function(Contact contact)? contact,
    TResult? Function(String name)? unknownContact,
  }) {
    return unknownContact?.call(name);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(PublicKey publicKey)? publicKey,
    TResult Function(Contact contact)? contact,
    TResult Function(String name)? unknownContact,
    required TResult orElse(),
  }) {
    if (unknownContact != null) {
      return unknownContact(name);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_PropertyAccessPublicKey value) publicKey,
    required TResult Function(_PropertyAccessContact value) contact,
    required TResult Function(_PropertyAccessUnknownContact value)
        unknownContact,
  }) {
    return unknownContact(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_PropertyAccessPublicKey value)? publicKey,
    TResult? Function(_PropertyAccessContact value)? contact,
    TResult? Function(_PropertyAccessUnknownContact value)? unknownContact,
  }) {
    return unknownContact?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_PropertyAccessPublicKey value)? publicKey,
    TResult Function(_PropertyAccessContact value)? contact,
    TResult Function(_PropertyAccessUnknownContact value)? unknownContact,
    required TResult orElse(),
  }) {
    if (unknownContact != null) {
      return unknownContact(this);
    }
    return orElse();
  }
}

abstract class _PropertyAccessUnknownContact extends PropertyAccessRecipient {
  const factory _PropertyAccessUnknownContact({required final String name}) =
      _$_PropertyAccessUnknownContact;
  const _PropertyAccessUnknownContact._() : super._();

  String get name;
  @JsonKey(ignore: true)
  _$$_PropertyAccessUnknownContactCopyWith<_$_PropertyAccessUnknownContact>
      get copyWith => throw _privateConstructorUsedError;
}
